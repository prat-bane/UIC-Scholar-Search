<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Shapley Values for Explanation in Two-sided Matching Applications</title>
				<funder ref="#_map8teG #_qUAHCUR #_3vmYKNQ">
					<orgName type="full">National Science Foundation</orgName>
					<orgName type="abbreviated">NSF</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Suraj</forename><surname>Shetiya</surname></persName>
							<email>suraj.shetiya@mavs.uta.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Texas at Arlington</orgName>
								<orgName type="institution" key="instit2">University of Illinois Chicago</orgName>
								<orgName type="institution" key="instit3">University of Illinois Chicago</orgName>
								<orgName type="institution" key="instit4">University of Texas at Arlington</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Ian</forename><forename type="middle">P</forename><surname>Swift</surname></persName>
							<email>iswift2@uic.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Texas at Arlington</orgName>
								<orgName type="institution" key="instit2">University of Illinois Chicago</orgName>
								<orgName type="institution" key="instit3">University of Illinois Chicago</orgName>
								<orgName type="institution" key="instit4">University of Texas at Arlington</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Abolfazl</forename><surname>Asudeh</surname></persName>
							<email>asudeh@uic.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Texas at Arlington</orgName>
								<orgName type="institution" key="instit2">University of Illinois Chicago</orgName>
								<orgName type="institution" key="instit3">University of Illinois Chicago</orgName>
								<orgName type="institution" key="instit4">University of Texas at Arlington</orgName>
							</affiliation>
						</author>
						<author>
							<persName><forename type="first">Gautam</forename><surname>Das</surname></persName>
							<email>gdas@cse.uta.edu</email>
							<affiliation key="aff0">
								<orgName type="institution" key="instit1">University of Texas at Arlington</orgName>
								<orgName type="institution" key="instit2">University of Illinois Chicago</orgName>
								<orgName type="institution" key="instit3">University of Illinois Chicago</orgName>
								<orgName type="institution" key="instit4">University of Texas at Arlington</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Shapley Values for Explanation in Two-sided Matching Applications</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="MD5">73DEF3B98141D39ABE17D0F454587F77</idno>
					<idno type="DOI">10.48786/edbt.2024.50</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.2" ident="GROBID" when="2025-11-27T23:17+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<label type="revision">a91ee48</label>
					<label type="parameters">startPage=-1, endPage=-1, consolidateCitations=0, consolidateHeader=1, consolidateFunders=0, includeRawAffiliations=false, includeRawCitations=false, includeRawCopyrights=false, generateTeiIds=false, generateTeiCoordinates=[], sentenceSegmentation=false, flavor=null</label>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In this paper, we initiate research in explaining matchings. In particular, we consider the large-scale two-sided matching applications where preferences of the users are specified as (ranking) functions over a set of attributes and matching recommendations are derived as top-k. We consider multiple natural explanation questions, concerning the users of these systems. Observing the competitive nature of these environments, we propose multiple Shapley-based approaches for explanation. Besides exact algorithms, we propose a sampling-based approximation algorithm with provable guarantees to overcome the combinatorial complexity of the exact Shapley computation. Our extensive experiments on real-world and synthetic data sets validate the usefulness of our proposal and confirm the efficiency and accuracy of our algorithms. 1 tinder.com; okcupid.com; bumble.com  2 linkedin.com; indeed.com; ziprecruiter.com  3 As we shall explain in Â§ 5, matching has many different formulations, properties, and applications. In this paper, our scope is limited only to bipartite many-many matching for two-sided online platforms.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Beyond its traditional use <ref type="bibr" target="#b0">[1]</ref><ref type="bibr" target="#b1">[2]</ref><ref type="bibr" target="#b2">[3]</ref>, matching has been a core functionality of many of the modern two-sided online platforms <ref type="bibr" target="#b3">[4]</ref><ref type="bibr" target="#b4">[5]</ref><ref type="bibr" target="#b5">[6]</ref>, including dating applications such as Tinder, OkCupid, and Bumble 1 , employment-oriented platforms such as Linkedin, Indeed, and Zip-Recruiter 2 , and many more. The two-sided matching platforms provide matching recommendations between two types of stakeholders (users). To better explain the matchings, let us consider Example 1.1 as a running example across the paper.</p><p>Example 1.1. (Part 1) Consider a two-sided employmentmatching application with two types of users, namely job candidates and human resource (HR) users. The application provides matching recommendations to both users, candidates and HRs. For example, a HR who looks at potential candidates for interview (either directly or indirectly) specifies a set of criteria and their preferences. Then the application returns a set of potential job candidates to the HR. It similarly finds matching job opportunities for the candidates.</p><p>Matching in two-sided platforms can be modeled as a bipartite graph 3 where users on one side are matched to the users on the other side. For instance, Figure <ref type="figure">1</ref> illustrates Example 1.1 as a bipartite graph, where job candidates and HRs are specified as red and blue nodes, respectively, while an edge ğ‘¡ ğ‘– â†’ ğ‘¡ ğ‘— means that ğ‘¡ ğ‘– has been recommended as a match for ğ‘¡ ğ‘— . Application usually identifies the list of potential matches for each user (called match list in this paper) based on their "individual preferences". While classic matching problems assume that each party explicitly specifies their preference as a ranking over the entire set on the other side, this assumption is not feasible for modern matching applications, simply due to their numerous number of users, the short attention span of users, and in some cases privacy considerations. As a result, the preferences are instead implicitly specified. That is, every user is associated with a set of attributes, and the preference of each user is defined as a function over the attributes of the other-side parties. Preference functions are either learned or specified by the users. Matching application uses the user's preference function to shortlist a limited list of candidates (the top-ğ‘˜).</p><p>Lack of adequate explanations in these systems is a major issue where the users who are impacted by the decision may be interested to know more insights about the matching and why they (or others) do or do-not appear in certain match lists. To further elaborate on this, let us continue with Example 1.1.</p><p>Example 1.1. (Part 2) Looking back at Example 1.1-Part 1, suppose four attributes are considered for matching: Python, R, PHP, and Javascript. Each candidate has a skill level for each of these attributes, as does each HR, describing the nature of the job. Additionally, each Candidate and HR has an importance weight associated with each attribute, forming their preference as a linear function, while ğ‘˜ = 2. Suppose candidate ğ‘¡ 3 wants an explanation based on their matchings , which were either disappointing or pleasing.</p><p>Currently the system provides no explanation for any of the four scenarios below, for which ğ‘¡ 3 may be interested in transparency:</p><p>(1) ğ‘¡ 3 was disappointed to not make it to the top-2 of HR ğ‘¡ 20 . An explanation would provide value to ğ‘¡ 3 . (2) ğ‘¡ 3 was happy they made it into the top-2 of HR ğ‘¡ 19 . ğ‘¡ 3 is eager to know as to what sets them apart from the rest. (3) Top-2 of ğ‘¡ 3 consisted of {ğ‘¡ 19 , ğ‘¡ 20 }. An explanation for why these HRs are good recommendations would be useful. (4) Candidate ğ‘¡ 3 made it into the top-2 of HRs ğ‘¡ 14 , ğ‘¡ <ref type="bibr" target="#b18">19</ref> . ğ‘¡ 3 wants to know why they made it into these specific top-2s.</p><p>The lack of answers for these questions prevents transparency for Candidate ğ‘¡ 3 .</p><p>In this work, we create a framework to provide explanations to various queries which are commonly encountered by the users of two-sided matching applications. To the best of our knowledge, this is the first paper in explaining matchings. In particular, we observe that top-k (ranking) problem is inherently competitive. As a result, the outcome (score) of a preference function is not enough to realize if a user appears in a match list or not. What Table 4: The generated explanation for why Candidate ğ‘¡ 3 appears in the Top-Ks of the specific HRs .</p><p>matters in these settings is the relative position (rank) of a user with respect to other users who "compete" for the top-k positions. Such competitive environments are naturally explainable by Shapley values <ref type="bibr" target="#b6">[7]</ref> -a game theory concept that identifies the contribution of each player (each attribute in our context) for deriving an outcome (e.g., a top-k match list). Shapley values have been proven repeatedly to solve explainability problems across different contexts <ref type="bibr" target="#b7">[8]</ref><ref type="bibr" target="#b8">[9]</ref><ref type="bibr" target="#b9">[10]</ref>.</p><p>Based on this observation, we consider Shapley values as the core of our system for our explanations. We consider a set of possible explanation queries, and provide Shapely-based approaches to answer them. Exact computation of Shapley values is a combinatorially hard problem, requiring algorithms that are exponential to the number of players. On the other hand, users might find accurate approximation of the values appropriate for explanation. Therefore, we propose a sampling-based approximation algorithm with provable guarantees on run-time and approximation error. Our system enables explanations as demonstrated in Example 1.1 (Part 3).</p><p>Example 1.1. (Part 3) Using Shapley-based methods, we generate an explanation for each of the previous queries. These explanations take the form of a value for each of the skills and other features on which the matching is generated. A high value indicates that the feature was largely responsible for each of the four cases. The individual can then be provided with a general explanation as to what about them resulted in the various outcomes.</p><p>(1) (From Table <ref type="table" target="#tab_0">1</ref>) ğ‘¡ 3 is informed that they failed to be matched to HR ğ‘¡ 20 because they were not a good match with their PHP skills. However, based on their R skills alone, they would have been a good match for the job. (2) (From Table <ref type="table" target="#tab_1">2</ref>) ğ‘¡ 3 can be told that the reason they were in the top-2 of HR ğ‘¡ 19 is because they were an excellent match on R skills. They can also be informed that their Python skills were less but still beneficial towards the matching as well. (3) (From Table <ref type="table" target="#tab_2">3</ref>) Top-2 of ğ‘¡ 3 consisted of {ğ‘¡ 19 , ğ‘¡ 20 }. They are informed that this is largely because of the Python requirements of the HRs, and less so because of the R and JavaScript requirements.</p><p>(4) (From Table <ref type="table">4</ref>) Candidate ğ‘¡ 3 is provided the information that they made it into the Top-2 of HRs ğ‘¡ 14 , ğ‘¡ 19 because of their Python skills first, then their PHP skills, then their R skills, and finally their JavaScript skills, with each contributing slightly less than the previous.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary of contributions.</head><p>In summary, our contributions are as follows:</p><p>â€¢ In this paper, we initiate a study of a novel problem -that of providing explanations for matching and top-k recommendation systems. To the best of our knowledge, this paper is the first to study explanation for matching. â€¢ We propose four explainability problems on the top-ğ‘˜ matching model which help in providing transparency to the system and white boxing the blackbox function.</p><p>â€¢ Considering the competitive nature of our matching problem, we propose a Shapley-based approach to explain the queries and provide run time analysis for each of the problems. We show the need for alternate methods, as the run time is bound exponentially by the number of dimensions. â€¢ We propose a sampling based approach to compute approximate Shapley values and prove guarantees on the trade-offs between number of samples and error rate. We adapt Ker-nelSHAP as a practical heuristic to our problem. â€¢ Extensive experimental analysis are provided for the various query settings and error guarantees, and our methods are evaluated in the real world via a user study.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARIES</head><p>Data model: We consider a dataset D with a Boolean attribute for matching (blue and red), ğ‘‘ numeric or categorical attributes A = {ğ´</p><p>1 â€¢ â€¢ â€¢ ğ´ ğ‘‘ }. The dataset D consists of ğ‘› entities ğ‘¡ 1 to ğ‘¡ ğ‘› , with a sizeable number of blues and reds. We use the notation ğ‘¡ ğ‘– [ ğ‘—] to refer to the value of the attribute ğ´ ğ‘— for the entity ğ‘¡ ğ‘– . Similarly, we use ğ‘¡ ğ‘– [ğ‘š] to refer to the type of ğ‘¡ ğ‘– , i.e. the value of the Boolean matching attribute on ğ‘¡ ğ‘– . The values in the dataset D (numeric or categorical represent the scores of each entity for various attributes, which are used in the matching process.</p><p>Note on distinct attributes for blues and reds: Our data model uses the same set of attributes for both the blue and red entities.</p><p>All the concepts and techniques defined later in the paper can be easily modified to work with a data-model where the blue entities have a different set of attributes (ğ‘‘ 1 ) compared to the red (ğ‘‘ 2 attributes). For the sake of simplicity, our data model is defined with symmetric attributes for both the blue and red entities.</p><p>Ranking functions: Each entity ğ‘¡ ğ‘– âˆˆ D is associated with a ranking (aka preference or scoring) function that maps any given entity to a real valued score ğ‘“ : R ğ‘‘ â†’ R + . The ranking function is used to express the preference of an entity during the matching process. As a hard criteria for matching, an entity with blue matching attribute only wants to match with an entity with red matching attribute and vice-versa. For instance, job recruiters (blue) and job seekers (red) are trying to match in a job matching scenario. The list of ranking functions ğ¹ consists of ğ‘› ranking functions corresponding to each of the entities. An entity ğ‘¡ ğ‘– 's ranking function is referred to as ğ‘“ ğ‘– throughout the paper. Some widely used types of ranking functions are linear, nearest-neighbor, and monotonic <ref type="bibr" target="#b10">[11]</ref>. The techniques proposed in this paper are agnostic to the choice of ranking function. In this paper, the time taken to compute a score by the ranking function is referred to as ğ¶. An important requirement for the ranking functions we consider in this paper is the masking property. That is, given a ranking function, one can tune the function not to consider masked attributes when computing the scores.</p><p>Masking is usually possible (including in linear, nearest-neighbor, and monotonic functions) by setting the values of the masked attributes as zero or null across all entities. That is, given an attribute ğ´ ğ‘— to mask, one can set ğ‘¡ ğ‘– [ ğ‘—] = 0, âˆ€ğ‘¡ ğ‘– âˆˆ D. The set of attributes ğ‘€ which are set to 0s (or nulls) are known as masked attributes. The purpose of the masking function is to generate the outcome of a subset of non-masked attributes. Please note that in case of categorical attributes, the ranking function must be able to handle null values. In later sections, we explain the importance of the masking property for explanations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Match list:</head><p>As there are a large number of entities, any entity would like to see a small relevant set of entities as a potential match. Ranking functions are used to rank all the entities in the dataset belonging to the opposite matching attribute. In this work, top-ğ‘˜ entries are shown for each entity using the rank of the entities as potential match. That is, given the ranking function ğ‘“ ğ‘– for an entity ğ‘¡ ğ‘– , scores are assigned to all the entities</p><formula xml:id="formula_0">{ğ‘¡ ğ‘— âˆˆ D | ğ‘¡ ğ‘— [ğ‘š] â‰  ğ‘¡ ğ‘– [ğ‘š]} using ğ‘“ ğ‘– .</formula><p>Those entities are then ranked and the top-ğ‘˜ are chosen to be shown to ğ‘¡ ğ‘– . These top-ğ‘˜ entries, known as a match list, are used to express the recommendations for matching. We denote a match list by ğ‘™ ğ‘– , such that each list consists of ğ‘˜ entities. Given an entity ğ‘¡ ğ‘– , let ğ‘“ ğ‘˜ ğ‘– represent the score for the ğ‘˜ ğ‘¡â„ ranked entity using the scoring function ğ‘“ ğ‘– . Given an entity ğ‘¡ ğ‘– ,the match list can be mathematically expressed as,</p><formula xml:id="formula_1">ğ‘™ ğ‘– = {ğ‘¡ ğ‘— | ğ‘“ ğ‘– (ğ‘¡ ğ‘— ) â‰¥ ğ‘“ ğ‘˜ ğ‘– ğ‘ğ‘›ğ‘‘ ğ‘¡ ğ‘— [ğ‘š] â‰  ğ‘¡ ğ‘– [ğ‘š]} ğ‘ .ğ‘¡ . |ğ‘™ ğ‘– | = ğ‘˜</formula><p>When a mask ğ‘€ is applied to obtain the top-ğ‘˜, the match list is represented as ğ‘™ ğ‘– (ğ‘€). Note that the value of ğ‘˜ depends on the application and is not restricted to a fixed value for any individual. Without loss of generality, in this paper we assume a consistent ğ‘˜ across all entities' ranking functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Problem definition</head><p>Our objective in this paper is to increase responsibility in matching systems by providing individuals with explanations about the matching and further information regarding why the matches occurred the way they did. The matching model for which explanations are being provided is called the "Top-ğ‘˜ matching model", which is formally defined as: Definition 2.1 (Top-ğ‘˜ matching model). Given a dataset of entities D, an integer ğ‘˜ and ranking function for each of the entities, determine the match lists of each of the entities using the top-ğ‘˜ from the ranked list.</p><p>When match list ğ‘™ ğ‘– is provided for a problem instance, it may not be clear how the various attributes contributed to the outcome.To solve this problem, an explanation is provided which identifies the role of different attributes in producing the outcome.</p><p>Definition 2.2 (Explanation). Given an output of a function ğ‘¦ = ğ‘“ (ğ´ 1 , ğ´ 2 , ...ğ´ ğ‘‘ ), determine the impact on producing the overall value ğ‘¦ of each attribute ğ´ ğ‘– when ğ´ ğ‘– is included as a parameter.</p><p>We now transition into explainability problems which help in making the system transparent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Point</head><p>Queries. The first two types of explanations are when an entity queries about their presence or absence from another entity's match list. This type of explanation is simply called a "point query".</p><p>In Example 1.1, Candidate ğ‘¡ 3 finds that they are not present in ğ‘¡ 20 's match list. In such a scenario, ğ‘¡ 3 would want an explanation for: why ğ‘¡ 3 is not present in ğ‘¡ 20 's match list? Such a problem/scenario where Candidate ğ‘¡ 3 would like an explanation for why they were not present in ğ‘¡ 20 's list, can be formally defined as follows:</p><p>PQ-NotMatch : Given a dataset D and entities ğ‘¡ ğ‘– and ğ‘¡ ğ‘— determine the contribution of attributes ğ´ 1 , . . . , ğ´ ğ‘‘ in ğ‘¡ ğ‘— not appearing in match list of ğ‘¡ ğ‘– .</p><p>Conversely, again using Example 1.1, Candidate ğ‘¡ 3 may also be interested in what factors were responsible for them to be present in the match list of HR ğ‘¡ 19 . In this scenario, the Candidate, seeking to understand the scenario, might request for an explanation as to: why ğ‘¡ 3 is present in ğ‘¡ 19 's match list? Formally, PQ-Match : Given a dataset D and entities ğ‘¡ ğ‘– and ğ‘¡ ğ‘— determine the contribution of attributes ğ´ 1 , . . . , ğ´ ğ‘‘ to ğ‘¡ ğ‘— appearing in match list of ğ‘¡ ğ‘– .</p><p>The next two queries deal with set based properties and hence, we term these as Set queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Set queries.</head><p>A different type of query that Candidate ğ‘¡ 3 from Example 1.1 might ask pertains to the match list. The candidate ğ‘¡ 3 might also be curious, based on their ranking function ğ‘“ 3 , why the match list ğ‘™ 3 was generated some way, either because they are happy or disappointed with the list that was provided to them. Formally, the query, why does an entity's match list look a certain way, can be formulated as, SQ-Single : Given a dataset D and an entity ğ‘¡ ğ‘– with a match list of ğ‘™ ğ‘– , determine the contribution of attributes ğ´ 1 , . . . , ğ´ ğ‘‘ to ğ‘¡ ğ‘– 's match list looking like ğ‘™ ğ‘– .</p><p>Finally, in addition to point queries and understanding their own ranking, Candidate ğ‘¡ 3 from Example 1.1 may be concerned with the outcome of being ranked by others. Particularly, they may be interested in what attributes about them influence the set of match lists in which they appear. Such an explanation can help Candidate ğ‘¡ 3 understand the factors responsible for their current matches, for both cases where they are either pleased or displeased with the results. If Candidate ğ‘¡ 3 is overall displeased with the HRs who match with them, knowing what attributes are responsible for this outcome can be informative. Equally, if they are consistently pleased with the HRs with whom they match, knowing the attributes that contribute to this outcome can provide insight into what went right. Formally, the problem to determine factors that influence an entity appearing in the match list of other entities is defined as: SQ-Multiple : Given a dataset D and an entity ğ‘¡ ğ‘– from the match list of a set of ğ‘‡ entities, determine the contribution of attributes ğ´ 1 , . . . , ğ´ ğ‘‘ for ğ‘¡ ğ‘– appearing in the match lists of ğ‘‡ entities.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SHAPLEY VALUE BASED SOLUTION</head><p>We start this section with discussing why Shapley values are suitable for explaining top-k and bipartite matching problems, followed by an overview of Shapley technique. Next, we show the transformation of our problem to Shapley, and discuss its scalability issue for higher dimensions. Then, we propose a samplingbased approximation technique with provable guarantees. We conclude the section by adapting KernelSHAP as a practical heuristic to solve our problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Why Shapley?</head><p>Scoring and ranking functions have been well-studied topics, while a major focus has been on explaining scoring functions. Even though there are similarities between scoring and ranking, their underlying requirements bring out drastic differences <ref type="bibr" target="#b11">[12]</ref>. The score of an entity only depends on the (attributes) of the entity itself. On the other hand, the rank of an entity depends not only on its attribute values, but also on the attribute values of the other entities in the dataset. Consider an entity ğ‘¡ in a dataset D. ğ‘“ (ğ‘¡) assigns a score to ğ‘¡. However, to find out the rank of ğ‘¡, one first needs to compute ğ‘“ (ğ‘¡ â€² ) for every entity in D, and then find the position of ğ‘¡ in the sorted list of entities based on ğ‘“ .</p><p>Because our problem is based on ranking, methods for scoring are no longer applicable for many queries. For example, in a (score-based) classification task, the attribute with the highest weight in the scoring function would be the most impactful. However, in a ranking problem, the score values are important only in comparison with the score of other entities. As a result, it is not enough if the score of an entity is high; what matters is that it is higher than other entities in the dataset. In this situation, an attribute ğ´ ğ‘– with a low weight in the scoring function can become important if dataset entities have a high variance on it. This is because the ranking is determined by competition between the entities, which is not captured simply by the score on a single entity. Let us illustrate this with Example 3.1.  <ref type="table" target="#tab_5">5</ref>. The entities belong to the same matching group. Let the scoring function for an entity belonging to the opposite group be the linear function ğ‘“ (ğ‘¡ ğ‘– ) = 5ğ‘¡ ğ‘– <ref type="bibr" target="#b0">[1]</ref> + 4ğ‘¡ ğ‘– <ref type="bibr" target="#b1">[2]</ref> + ğ‘¡ ğ‘– <ref type="bibr" target="#b2">[3]</ref>. For this example, let the Hence, the match list looks like {ğ‘¡ 3 , ğ‘¡ 5 } after the ranking function is applied. By looking at the entities, the entity whose ranking function is used for ranking might question why is ğ‘¡ 1 not in the top-ğ‘˜? An explanation model based on scoring functions would emphasize on weights of the given query entity to obtain the contribution of the different attributes. The weights for ğ´ 1 ( <ref type="formula" target="#formula_6">5</ref>) is the highest, followed by ğ´ 2 (4) and ğ´ 3 <ref type="bibr" target="#b0">(1)</ref>. Looking at these weights, a scoring based explanation approach would conclude that either of ğ´ 1 or ğ´ 2 might be responsible for the query result. But upon masking attributes {ğ´ 1 }, {ğ´ 2 } or {ğ´ 1 , ğ´ 2 } and re-ranking one can observe that ğ‘¡ 3 and ğ‘¡ 5 are always scored higher than ğ‘¡ 1 . On the other hand upon masking attribute {ğ´ 3 }, one can see that ğ‘¡ 1 enters the match list. This illustrates the combinatorial feature importance in explaining ranking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Note on normalization:</head><p>A common technique used to handle disproportionate scores is normalization. For the example above, we illustrate that attributes with high-weights post normalization does not answer our query correctly. For our scenario, one could normalize each attribute ğ´ ğ‘– using ğ‘¡ [ğ‘–]/ğ‘šğ‘ğ‘¥ ğ‘– , where ğ‘šğ‘ğ‘¥ ğ‘– represents the maximum value for attribute ğ´ ğ‘– . Attributes ğ´ 1 , ğ´ 2 and ğ´ 3 can be normalized by dividing each of the tuples values for the corresponding attributes by 10.1, 1.8 and 32. As we have scaled the attributes using normalization, the weights for the scoring functions also need to be adjusted by multiplying by 10.1, 1.8 and 32 respectively. Thus, the scaled weights from the normalization process are &lt; 50.5, 7.2, 24 &gt;. As the contribution of each attribute in the Shapley function have remained same, the normalization process did not change the Shapley scores. Yet, attribute ğ´ 1 attribute has a higher weight than ğ´ 3 . The high weight on ğ´ 1 still produces an improper explanation for our scenario.</p><p>Since ranking is based on the competition between entities, it is natural to map our problem using coalitional game theory. In a coalitional game, different players of a coalition in a competitive game compete for utility. Accordingly, we utilize coalitional game theory to capture the importance of different attributes.</p><p>Shapley value <ref type="bibr" target="#b6">[7]</ref> is a concept in coalitional game theory which allows one to compute the importance of each of the players in the game to the outcome. Each game contains a set of ğ‘› players and a utility function ğ‘£ : 2 ğ‘› â†’ R, which determines the worth of the subset of players. Note that the utility of an empty set of players is 0, ğ‘£ (âˆ…) = 0 as the value represents the worth of an empty set (âˆ…) of players. The average contribution by each of the players to the outcome of the game can be defined for each player ğ‘– as the Shapley value ğ‘†â„ ğ‘– . Shapley value for the game is given by,</p><formula xml:id="formula_2">ğ‘†â„ ğ‘– = 1 ğ‘›! âˆ‘ï¸ ğ‘‹ âˆˆğ‘† ğ‘¦ğ‘š (ğ‘ ) (ğ‘£ (ğ‘ƒğ‘Ÿğ‘’ ğ‘‹ ğ‘– âˆª ğ‘–) -ğ‘£ (ğ‘ƒğ‘Ÿğ‘’ ğ‘‹ ğ‘– ))<label>(1)</label></formula><p>where ğ‘†ğ‘¦ğ‘š(ğ‘ ) represents the Symmetric group of set N, and ğ‘ƒğ‘Ÿğ‘’ ğ‘‹ ğ‘– represents the players preceding ğ‘– in permutation ğ‘‹ . Equation 1 captures the marginal increase in contribution of a player ğ‘– to its predecessors in permutation ğ‘‹ .</p><p>An alternate form of Equation 1 can be used to compute the Shapley values. For a given subset ğ‘† of players, there exist |ğ‘† |!(ğ‘› -|ğ‘† | -1)! permutations each of which have the same utility value whose re-computation is avoided when using the alternate form given below,</p><formula xml:id="formula_3">ğ‘†â„ ğ‘– = âˆ‘ï¸ ğ‘† âŠ†ğ‘ \{ğ‘– } |ğ‘† |!(ğ‘› -|ğ‘† | -1)! (ğ‘›!) (ğ‘£ (ğ‘† âˆª {ğ‘–}) -ğ‘£ (ğ‘†))<label>(2)</label></formula><p>Even though the formula is helpful in reducing the complexity from ğ‘›! to 2 ğ‘› , the computation is still exponential. Accordingly, in practice, as the number of attributes grow this process tends to become infeasible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Mapping Shapley value to matching</head><p>In Example 3.1, we argued that ideas such as using attributeweights in the scoring function may not be effective for explaining top-k matchings. Alternatively, we propose to map attributes {ğ´ 1 , ğ´ 2 , â€¢ â€¢ â€¢ , ğ´ ğ‘‘ } as players of a coalitional game, compute the contribution of each attribute using the concept of Shapley values, and use these values to explain matchings. Indeed, an attribute's contribution is query dependent. That is, for different explainability queries, its contribution may vary from one query to the other. For instance, in Example 1.1, the contribution of the attribute (skill) Java for the query "why is ğ‘¡ 3 in the match list of ğ‘¡ 19 " is different from "why is ğ‘¡ 3 not in the match list of ğ‘¡ 20 ".</p><p>We design a utility function ğ‘£ based on the query, which takes in a set of attributes ğ‘† âŠ† A and maps it to a utility score which is a real value R (i.e. ğ‘£ : 2 ğ‘‘ â†’ R). For a given subset ğ‘†, the masked attributes are the attributes that are absent in ğ‘† ( i.e. ğ‘€ = ğ´\ğ‘†). Due to this operation, our technique expects the ranking function to support masking. We provide design details of the utility function for different queries in Â§ 3.3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Shapley value in matching</head><p>One of our contributions is to transform each of our explanation problems to Shapley value computation problem and define a utility function over the set of attributes. This section provides the details for the Shapley value based approach applied to the four types of explainability queries defined in Â§ 2.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.1">PQ-NotMatch.</head><p>Consider the scenario when a dataset of entities D and two entities ğ‘¡ ğ‘– and ğ‘¡ ğ‘— are provided for a query type of PQ-NotMatch. The attributes (players) responsible for ğ‘¡ ğ‘— not appearing in ğ‘¡ ğ‘– 's match list would be valued high.</p><p>To reflect this we define a value function that returns a 1 (0 resp.) based on if an the entity ğ‘¡ ğ‘— 's absence (presence resp.) in ğ‘¡ ğ‘– 's match list ğ‘™ ğ‘– for a subset of attributes ğ‘†. In this case, the set of attributes has contributed to a failed match and hence a value (reward) of 1. On the flip side, the utility function returns 0 if ğ‘¡ ğ‘— is present in ğ‘™ ğ‘– for a given subset of attributes ğ‘†. To explain further with Example 1.1 (1), the utility function would return 1 if ğ‘¡ 3 was not present in ğ‘™ * 20 and 0 otherwise. Assuming ğ‘™ * ğ‘– is the match list computed based on strictly the attributes in set ğ‘†, the utility function ğ‘£ can thus be defined as,</p><formula xml:id="formula_4">ğ‘£ (ğ‘†) = 0, if ğ‘† = âˆ… or ğ‘¡ ğ‘— âˆˆ ğ‘™ * ğ‘– 1, if ğ‘¡ ğ‘— âˆ‰ ğ‘™ * ğ‘– (3)</formula><p>For Example 1.1 question (1), and the query PQ-NotMatch, the results are shown in Table <ref type="table" target="#tab_0">1</ref>. The exact algorithm generated the Shapley values 0, -0.16, 0.83, and 0.33 for the attributes Python, R, PHP, and JS respectively. As discussed earlier, this shows that PHP is the largest contributor to why Candidate ğ‘¡ 3 was not in HR ğ‘¡ 20 's match list. Additionally, since Python has a negative value, the candidate's Python skill would cause the individual to appear in the match list.</p><p>3.3.2 PQ-Match. The next explainability query which can be calculated using Shapley value is the second query PQ-Match. A similar approach that we have seen so far can be extended to this scenario.</p><p>In the PQ-Match utility function, a value of 1 (reward) is returned if ğ‘¡ ğ‘— is present in ğ‘¡ ğ‘– 's match list ğ‘™ ğ‘– for a given subset of attributes ğ‘†. Alternatively, ğ‘£ returns 0 if ğ‘¡ ğ‘— is absent from ğ‘¡ ğ‘– 's match list ğ‘™ ğ‘– for a subset of attributes ğ‘†, as in this case ğ‘† has not contributed to a successful match. Again, ğ‘™ * ğ‘– is the match list computed based on strictly the attributes in set ğ‘†. To illustrate this with Example 1.1 (2), the utility function ğ‘£ would return 1 if ğ‘¡ 3 was present in ğ‘™ * 19 and 0 otherwise. Utility function ğ‘£ for PQ-Match can thus be defined as,</p><formula xml:id="formula_5">ğ‘£ (ğ‘†) = 0, if ğ‘† = âˆ… or ğ‘¡ ğ‘— âˆ‰ ğ‘™ * ğ‘– 1, if ğ‘¡ ğ‘— âˆˆ ğ‘™ * ğ‘– (4)</formula><p>Continuing with Example 1.1 question (2), the results for PQ-Match can be seen in Table <ref type="table" target="#tab_1">2</ref>. The exact algorithm generated the Shapley values 0.25, 0.91, -0.08, and -0.08 for the attributes Python, R, PHP, and JS respectively. By far the largest contributor to Candidate ğ‘¡ 3 being in HR ğ‘¡ 19 's match list is the candidate's R skills. Additionally, both PHP and JS can be seen as having a negative value, negatively impacting Candidate ğ‘¡ 3 being in the match list.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.3">SQ-Single.</head><p>Utility functions for queries based on match lists explain more complicated problems than the previous two queries. This is due to these queries use differences in the match list, instead of presence or absence from the match list.</p><p>Consider the scenario where a dataset of entities D and an entity ğ‘¡ ğ‘– with a match list of ğ‘™ ğ‘– are provided for the query type of SQ-Single. The utility function must capture the similarity of the computed top-ğ‘˜ match list for the set of attributes ğ‘†, ğ‘™ * ğ‘– , with match lists for the full set of attributes A, ğ‘™ ğ‘– . As the explanation relies on the top-ğ‘˜ items, ğ‘™ ğ‘– , and its similarity with ğ‘™ * ğ‘– , we can use the Jaccard similarity between these two sets as the utility function. The Jaccard similarity is a value between 0 and 1. The value 0 indicates that the sets share no common elements and 1 indicates that the sets ğ‘™ ğ‘– and ğ‘™ * ğ‘– are identical. To further explain with Example 1.1 (3), ğ‘£ is the Jaccard similarity of the match list of entity ğ‘¡ 3 (ğ‘™ 3 {ğ‘¡ 19 , ğ‘¡ 20 }) with ğ‘™ * 3 . The utility function ğ‘£ can be expressed as,</p><formula xml:id="formula_6">ğ‘£ (ğ‘†) = 0, if ğ‘† = âˆ… |ğ‘™ ğ‘– âˆ©ğ‘™ * ğ‘– | |ğ‘™ ğ‘– âˆªğ‘™ * ğ‘– | , ğ‘œğ‘¡â„ğ‘’ğ‘Ÿğ‘¤ğ‘–ğ‘ ğ‘’<label>(5)</label></formula><p>Again, with Example 1.1 question (3), the results for SQ-Single are shown in Table <ref type="table" target="#tab_2">3</ref>. The exact algorithm generated the Shapley values 0.61, 0.28, 0.0, and 0.11 for the attributes Python, R, PHP, and JS respectively. The largest contributor to Candidate ğ‘¡ 3 's match list being the way it was, is the Python requirement of the HRs, however to a lesser degree the R requirements contributed, and even lesser, the JS requirements contributed.</p><p>It is worth noting that our Shapley function does not distinguish the order/rank of the entities within the (top-k) match-list, i.e., it treats them as a set. Therefore, it uses Jaccard similarity, the metric for computing set similarities. But if the order of the items within the top-k is important, value function needs to account for any change within the ranking of the match-list.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3.4">SQ-Multiple.</head><p>A similar approach of using Jaccard similarity can be used to find the contribution of each attribute for the SQ-Multiple problem. Consider the scenario when a dataset D and an entity ğ‘¡ ğ‘– is provided. The entity ğ‘¡ ğ‘– is present in the match list of ğ‘‡ âŠ† ğ‘‚ entities. For a subset ğ‘† âŠ† A of attributes, let ğ‘‡ * be the set of entities in whose match list ğ‘¡ ğ‘– is present for the attributes ğ‘†. The utility function represents the similarity between the set ğ‘‡ * and ğ‘‡ .</p><p>A similarity of 0 indicates there are no shared elements between the two match lists, where a similarity of 1 indicates that the sets are identical. A smaller value indicates a smaller intersection or a higher union, and a larger value indicates a larger union or a smaller intersection. From the running Example 1.1 (4), the set of entities whose match list consist of ğ‘¡ 3 is ğ‘‡ = {ğ‘¡ 14 , ğ‘¡ 19 }. Hence, the function ğ‘£ for this case would compute the Jaccard similarity between {ğ‘¡ 14 , ğ‘¡ 19 } and ğ‘‡ * for a subset of attributes ğ‘† âŠ† A. The value function ğ‘£ can be expressed as,</p><formula xml:id="formula_7">ğ‘£ (ğ‘†) = ï£± ï£´ ï£´ ï£´ ï£² ï£´ ï£´ ï£´ ï£³ 0, if ğ‘† = âˆ… 1, if ğ‘† â‰  âˆ… &amp; |ğ‘‡ âˆª ğ‘‡ * | = 0 |ğ‘‡ âˆ©ğ‘‡ * | |ğ‘‡ âˆªğ‘‡ * | , ğ‘œğ‘¡â„ğ‘’ğ‘Ÿğ‘¤ğ‘–ğ‘ ğ‘’<label>(6)</label></formula><p>Finally, for Example 1.1 question (4), the results for SQ-Multiple are shown in Table <ref type="table">4</ref>. The exact algorithm generated the Shapley values 0.48 3, 0.23 3, 0.33 3, and 0.15 for the attributes Python, R, PHP, and JS respectively. All of the candidates skills contributed somewhat, but Python, PHP, R, and JS contributed in descending order of importance.</p><p>Having mapped Shapley values to the top-ğ‘˜ matchings, we can now explain matchings using the attribute contributions, as shown in Example 3.1 (Part 2).</p><p>Example 3.1. (Part 2) Looking at Table <ref type="table" target="#tab_5">5</ref>, the Shapley values of {ğ´ 1 , ğ´ 2 , ğ´ 3 } for the query "why is ğ‘¡ 1 not in the top-ğ‘˜?" are computes as {-0.16, 0.33, 0.83}, using Equation <ref type="formula" target="#formula_6">5</ref>. The high Shapley value of attribute ğ´ 3 indicates that ğ´ 3 can explain the query the most. The impact of attribute ğ´ 3 is partially seen empirically when we remove the attribute. Removal of ğ´ 3 's impact on the linear ranking function is reflected in the new scores the entities get, ğ‘¡ 1 , ğ‘¡ 2 , ğ‘¡ 3 , ğ‘¡ 4 and ğ‘¡ 5 get a score of 54 , 10.4, 49.8, 53.5, 57.7 respectively. These scores show that the entity ğ‘¡ 1 is present in the match list when ğ‘˜ = 2 when ğ´ 3 is removed, thus confirming its relative contribution. Proof. Computation of exact Shapley values using Equation <ref type="formula" target="#formula_3">2</ref>relies on computing the utility function efficiently over all subsets of A. We analyse the running time of each of the value functions of the 4 problems and prove that the exponential nature arises solely from Shapley value computation from Equation <ref type="formula" target="#formula_3">2</ref>. As noted in Â§ 2, we denote the amount of time taken by the ranking function as ğ¶. PQ-NotMatch: Consider a dataset D and entities (ğ‘¡ ğ‘– and ğ‘¡ ğ‘— ). The value function used for PQ-NotMatch is given in Equation <ref type="formula">3</ref>. Given a subset of attributes ğ‘† âŠ† A, the time taken to recompute the ranking function for an entity is ğ¶. As there are ğ‘› entities, the function ğ‘£ takes ğ‘›ğ¶ time to obtain the scores for all entities. Obtaining the top-k (match list ğ‘™ * ğ‘– ) can be efficiently performed using the selection algorithm which takes a total of O (ğ‘›) time. Checking if the entity ğ‘¡ ğ‘— is present in the match list takes ğ‘˜ time. Hence, total time taken by function ğ‘£ is O (ğ‘›ğ¶) for a given subset ğ‘†. PQ-Match: Computation of the value function is similar to the computation of PQ-NotMatchand hence consumes O (ğ‘›ğ¶) time. SQ-Single: Consider a dataset D and entity ğ‘¡ ğ‘– with match list ğ‘™ ğ‘– when using all attributes A. The Shapley value function for SQ-Single is given in Equation <ref type="formula" target="#formula_6">5</ref>. The set based value function relies on Jaccard similarity between sets ğ‘™ ğ‘– and ğ‘™ * ğ‘– to obtain a value. Hence, the first step is similar to PQ-NotMatch and PQ-Match problems, i.e. computation of ğ‘™ * ğ‘– . The Jaccard similarity computation can be efficiently performed by sorting the match lists ğ‘™ ğ‘– and ğ‘™ * ğ‘– , followed by performing simultaneous linear scans on ğ‘™ ğ‘– and ğ‘™ * ğ‘– to obtain both the intersection and union. This step consumes a total of O (ğ‘˜ log (ğ‘˜)) time. Hence, the total time consumed is O (ğ‘›ğ¶ + ğ‘˜ log (ğ‘˜)) SQ-Multiple: Consider a dataset D and entity ğ‘¡ ğ‘– which is present in the match list of entities ğ‘‡ when using all attributes A. The Shapley value function for SQ-Single is given in Equation <ref type="formula" target="#formula_7">6</ref>. Given a subset of attributes ğ‘†, ğ‘‡ * can be obtained by first computing match list ğ‘™ * ğ‘— for all ğ‘› entities and checking which ones contain ğ‘¡ ğ‘– .</p><p>The computation of ğ‘™</p><p>* ğ‘— and checking if ğ‘¡ ğ‘– is present in ğ‘™ * ğ‘— (ğ‘¡ ğ‘– âˆˆ ğ‘™ * ğ‘— ) for a single entity consumes O (ğ‘›ğ¶) as seen above. As there are ğ‘› entities, obtaining ğ‘‡ * consumes a total of O (ğ‘› 2 ğ¶) time. Additionally, to compute the Jaccard similarity, (i) need to sort both ğ‘‡ and ğ‘‡ * , (ii) perform simultaneous scans on ğ‘‡ and ğ‘‡ * to obtain both intersection and union, and (iii) obtain the ratio. Steps (i) and (ii) consume O (ğ‘› log (ğ‘›)) time and (iii) consumes O (ğ‘› log (ğ‘›)) time. Hence, the overall time consumed is O (ğ‘› 2 ğ¶). The Shapley value computation for each of the four cases relies on generating all subsets of the set of attributes A. As there are ğ‘‘ attributes, generating the sets consumes a total of ğ‘‘ 2 ğ‘‘ time. Hence, the Shapley computation for all the four queries is exponential in ğ‘‘, the number of attributes A. â–¡ Note on limitations of Shapley based method: Kumar et al. [13] have shown certain limitations of Shapley-based methods while explaining machine learning models. During masking, these methods are shown to sample out-of-distribution data points which can affect the Shapley explanation model and create undesirable output. Matching-based applications are not subject to similar problems like machine learning models, as the whole process of top-k and bipartite matching is based on competition. These processes are less subject to changes in scores and instead rely on ranking between items. Nevertheless, we would like to note our dependence on the scoring functions to handle the NULL values generated during masking. Additionally, we would like to note that explanations generated from Shapley-based methods are not actionable and must be used as a means to whitebox the blackbox function. Designing Shapley value function for other queries: Intuitively, the design of the value function needs to capture the nature of the query. We illustrate this with modifications to existing value functions when the queries are modified. Let us consider the scenario of simultaneous matching. Consider the explainability query, find the attributes responsible for ğ‘¡ ğ‘– being present in ğ‘¡ ğ‘— 's match list and ğ‘¡ ğ‘— being present in ğ‘¡ ğ‘– 's match list simultaneously. While this query is similar to PQ-Match, value function needs to reward only when both the PQ-Match events occur simulataneously i.e. ğ‘¡ ğ‘– âˆˆ ğ‘™ * ğ‘— and ğ‘¡ ğ‘— âˆˆ ğ‘™ * ğ‘– . Based on this, the value function can be defined as follows. ğ‘£ (ğ‘†) = 0, if ğ‘† = âˆ… or (ğ‘¡ ğ‘– âˆ‰ ğ‘™ * ğ‘— or ğ‘¡ ğ‘— âˆ‰ ğ‘™ * ğ‘– ) 1, otherwise Let us now consider a scenario when the order within the top-k match list is important to the query. Consider the scenario when the entity ğ‘¡ ğ‘– wants to be near the top of ğ‘¡ ğ‘— 's match list. Let us assume that the ranking process is modified to provide a ordered list of ğ‘˜ entities instead of a set. With a little abuse of notation, let ğ‘™ * ğ‘— be the ordered match list of ğ‘¡ ğ‘— and ğ‘ * ğ‘– be the location of entity ğ‘¡ ğ‘– in ğ‘™ * ğ‘— . If ğ‘¡ ğ‘– was located at position 1 in ğ‘™ * ğ‘— , the value function needs to reward with a score of 1, otherwise the location ğ‘ * ğ‘– would define the reward. Based on the position ğ‘ * ğ‘– the value function is,</p><formula xml:id="formula_8">ğ‘£ (ğ‘†) = 0, if ğ‘† = âˆ… or ğ‘¡ ğ‘– âˆ‰ ğ‘™ * ğ‘— 1 - ğ‘ * ğ‘– -1 ğ‘˜ , otherwise</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Approximate sampling based approach</head><p>The prohibitive nature of the exact Shapley value algorithm has spurred research into approximate methods. Sampling based methods have been proposed to obtain approximate Shapley values. In this paper, we use the sampling based on permutations of attributes. Based on <ref type="bibr" target="#b13">[14]</ref>, the mean of the marginal contributions for each attribute ğ´ ğ‘– over the entire symmetric group ğ‘†ğ‘¦ğ‘š(ğ´) is equivalent to the corresponding Shapley value ğ‘†â„ ğ‘– . To approximate the value ğ‘†â„ ğ‘– , instead of calculating all members of the symmetric group, ğ‘ members of the ğ‘†ğ‘¦ğ‘š(ğ´) are sampled. The estimated Shapley value for attribute ğ´ ğ‘– resulting from the samples is referred as Åœâ„ ğ‘– throughout the paper. The expected value of a random sample from the uniform distribution is equivalent to the mean of that distribution such that ğ¸ğ‘¥ [ Åœâ„ ğ‘– ] = ğ‘†â„ ğ‘– .</p><p>A randomized approximation algorithm based on the sampling of permutations for computing the explanation queries is defined as follows. Initially, random sampling is performed to select ğ‘ permutations from ğ‘†ğ‘¦ğ‘š(ğ´). With Åœâ„ ğ‘– set to 0, Åœâ„ ğ‘– is increased by</p><formula xml:id="formula_9">1 ğ‘ Ã— (ğ‘£ (ğ‘ƒğ‘Ÿğ‘’ ğ‘‹ ğ‘– âˆª ğ´ ğ‘– ) -ğ‘£ (ğ‘ƒğ‘Ÿğ‘’ ğ‘‹ ğ‘– ))</formula><p>for each sampled permutation ğ‘‹ . The value Åœâ„ ğ‘– , is the approximate Shapley value for attribute ğ´ ğ‘– .</p><p>Sample size, q: The randomized approximate algorithm can be demonstrated to show that by varying ğ‘ and specifying an approximation bound ğ›¼, an error rate of ğœ– can be satisfied such that ğ‘ƒğ‘Ÿ (| Åœâ„ ğ‘– -ğ‘†â„ ğ‘– | &lt; ğ›¼) &gt; 1 -ğœ–. We prove in Theorem 3.3 that a for a given value of approximation bound ğ›¼ and error rate ğœ–, there exists a fixed samples size ğ‘ which satisfies ğ‘ƒğ‘Ÿ (| Åœâ„ ğ‘– -ğ‘†â„ ğ‘– | &lt; ğ›¼) &gt; 1 -ğœ– for our queries. Proof. We prove this theorem using Hoeffding's inequality <ref type="bibr" target="#b14">[15]</ref>. First, we prove for the four queries that each random variable ğ‘ ğ‘– varies within the range of ğ‘ ğ‘– âˆˆ [-1, 1]. The random variable ğ‘ ğ‘– in each of the four problems refers to the Shapley value function for the sampled permutation. We obtain the inequality by applying Hoeffding's inequality.</p><p>For the queries PQ-NotMatchand PQ-Match, the random variable is the difference between the Shapley value function when attribute ğ´ ğ‘– is added to permutation ğ‘‹ i.e. ğ‘ ğ‘– = (ğ‘£ (ğ‘ƒğ‘Ÿğ‘’ ğ‘‹ ğ‘– âˆª ğ´ ğ‘– ) -ğ‘£ (ğ‘ƒğ‘Ÿğ‘’ ğ‘‹ ğ‘– )). Hence, the random variable ğ‘ ğ‘– can take values -1, 0 or 1 based on how the Shapley value function changed.</p><p>For the set-similarity based problems SQ-Singleand SQ-Multiple ğ‘ ğ‘– is the difference between the Jaccard similarity for the random permutation ğ‘£ (ğ‘ƒğ‘Ÿğ‘’ ğ‘‹ ğ‘– âˆª ğ´ ğ‘– ) and ğ‘£ (ğ‘ƒğ‘Ÿğ‘’ ğ‘‹ ğ‘– ). Hence, ğ‘ ğ‘– for these two problems is a continuous variable between -1 and 1. As we have seen, in all four problems the random variable ğ‘ ğ‘– varies between -1 and 1. Applying Hoeffding's inequality with ğ‘ = 1 and ğ‘ = -1</p><formula xml:id="formula_10">we get, P | Åœâ„ ğ‘– -ğ‘†â„ ğ‘– | â‰¥ ğ›¼ â‰¤ 2ğ‘’ -ğ‘ğ›¼ 2 2</formula><p>â‰¤ ğ›¿. Restructuring the above equation and representing ğ‘ in terms of ğ›¼ and ğœ– we get,</p><formula xml:id="formula_11">ğ‘ â‰¥ 2 log (2/ğœ–) ğ›¼ 2</formula><p>Hence, proved. â–¡</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">KernelSHAP</head><p>Another technique to approximate Shapley values is SHAP <ref type="bibr" target="#b9">[10]</ref>.</p><p>SHAP proposes a linear model to explain black box machine learning model-prediction for a given input data point. KernelSHAP is a generalised SHAP approximation technique proposed by Lundeberg et. al. <ref type="bibr" target="#b9">[10]</ref>. The technique is built on top of LIME <ref type="bibr" target="#b15">[16]</ref> to approximate Shapley values. KernelSHAP provides the parameters to be set in the optimisation function of LIME such that the linear model finds the Shapley values. To the best of our knowledge, KernelSHAP does not inherently provide any guarantees on sample size unlike the sampling approach, but empirically performs better.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">EXPERIMENTS</head><p>We conduct extensive experiments on real-world and synthetic data to validate our proposal and to evaluate the performance of our algorithms. In the following, after discussing the experiment set up, we provide proof of concept experiments that focus on validating our results. Finally, the empirical evaluation of the different techniques is presented.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Experiments setup</head><p>4.1.1 Datasets. Matching datasets involving real-world entities are often not publicly available due to privacy concerns. Hence, in our experiments we considered two publicly-available real-world datasets, along with 12 configurations of synthetic datasets.</p><p>â€¢ Job candidates dataset (real world dataset)<ref type="foot" target="#foot_0">foot_0</ref> : 390 candidates were parsed from 22 columns, including 18 numerical columns, 3 categorical columns, and 1 set based column. Values for numerical columns were normalized to be a value between 0 and 1. To generate HR entities, uniform random values were selected for each column from the set of possible values for that column in the candidate dataset. â€¢ Graduate admissions dataset <ref type="bibr" target="#b16">[17]</ref>(real world dataset): The dataset consists of application details of 500 students to the graduate program. There are a total of 6 numerical features and a categorical feature. Each data point in the dataset also a dependant variable, chance of admit, which is a score between 0 and 1. â€¢ Synthetic dataset: There are many parameters that can be varied when generating the datasets. We have used 3 main factors, probability distribution, correlation between the attributes, and the number of attributes. Since our experimental study aims to assess our method across different settings, we generate multiple datasets for each setting and aggregate results for each setting. For the probability distribution, we consider Uniform and Zipfian distributions. Linear and non-linear ranking functions; correlated, anti-correlated, and independent attributes were used to ensure variety of data in our experiments. For each of these 12 settings, 10 datasets were generated bringing the total to 120 datasets. Each dataset consists of 1000 items each with 9 dimensions.</p><p>4.1.2 Hardware and Platform. All our experiments were performed on a work station with a Core i9 Intel X-series 3.5 GHz machine running Linux Ubuntu with 128 GB of DDR4 RAM. The algorithms were implemented in Python 3 <ref type="foot" target="#foot_1">5</ref> .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.3">Ranking function.</head><p>As the ranking / preference functions were not available for the real world datasets, we generated ğ‘› linear ranking functions. The ranking functions are based on proximity to the candidate's skills/ HR's requirements. For synthetic dataset, we have used both linear and non-linear ranking functions. For non-linear ranking functions, weighted squares of the attributes have been used to rank the entities. In the user study, the ranking function used for contrasting LIME and Shapley values explanations is learned using machine learning models based on the other features using AutoML which is then used to predict the chance of admit.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1.4">Algorithms Evaluated.</head><p>We have implemented the brute force Shapley value algorithm and the approximate Shapley value algorithms. We use the KernelSHAP library from github by Lundberg <ref type="foot" target="#foot_2">6</ref> .</p><p>As baselines to compare against, we use the weight based algorithm described in Â§ 3.1 and an attribute based baseline. The attribute based baseline ranks each of the attributes individually for a given query. More specifically, for a query we mask the set of attributes such that only one attribute is unmasked. We measure the effect of the individual attributes and then rank these attributes. For the PQ-NotMatch (PQ-Match resp.) query, we use the highest (least resp.) rank achieved by the entity when only using a single attribute as a measure to compare all attributes and rank them. As SQ-Single and SQ-Multiple queries are set based queries, we use the Jaccard similarity measure instead to rank the attributes. The comparison for these baselines is provided in Â§ 4.2.2. be mathematically written as, ğ‘“ ğ‘– (ğ‘¡) = 4 ğ‘—=1 ğ‘¤ ğ‘— |ğ‘¡ ğ‘– [ ğ‘—] -ğ‘¡ [ ğ‘—] | The equation above obtains the distance between the requirement and hence smaller distance is preferred.</p><p>Note that we have normalized each attribute between the values [0, 1]. The normalization for an attribute ğ´ ğ‘— is performed for any entity ğ‘¡ ğ‘– using,</p><formula xml:id="formula_12">ğ‘¡ ğ‘– [ ğ‘—] = ğ‘¡ ğ‘– [ ğ‘— ]-ğ‘šğ‘–ğ‘› (ğ´ ğ‘— ) ğ‘šğ‘ğ‘¥ (ğ´ ğ‘— )</formula><p>where ğ‘šğ‘–ğ‘› and ğ‘šğ‘ğ‘¥ find the minimum and maximum values for attribute ğ´ ğ‘— in the dataset D.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Proof of Concept</head><p>As our first set of experiments, we provide results to validate our proposal for explaining match lists using Shapley values. In particular, we first present a case study, discussing the explanations for specific cases in detail. Then, we provide an experiment to demonstrate the effectiveness of Shapley values for explanation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.1">Case Study.</head><p>We begin our proof of concept experiments by a case study to illustrate the usefulness of our explanations. Aligned with our running example (Example 1.1), we select a user from our experiments on job-candidates dataset, and discuss the generated explanation in detail. Approximate Shapley values produced using the sampling algorithm for PQ-NotMatch are shown in Table <ref type="table" target="#tab_8">6</ref>. Among their programming skills, the largest contributors to this result were R, React.js and CSS with Shapley values of 0.09, 0.09, and 0.085. In each of these cases, the candidate performed poorly on these skills while HR ranked these skills fairly highly relative to other programming skills. The lowest Shapley among programming skills value was Python, where the individual had the maximum score, but the weight was also the lowest relative to all skills. Overall, the highest Shapley value was for the Candidate's Master of Science degree, indicating that this degree (as opposed to another one) was the main reason the candidate was not placed on the match list. Finally, the overall lowest weights were their performances in grade 12, 10, and post grad, with scores of -0.05, -0.05 and -0.02. Negative Shapley values indicate that these skills worked against the candidate not being in the match list, and can be seen as skills that if evaluated solely on, the individual would appear in the match list. An explanation may appear as: "You were not matched with this HR largely due to your degree in Master of Science. Among your programming skills, the Please note that the Shapley value explanation does not provide a direction for improvement. An intuitive way of thinking about this is that Shapley values does not perturb the numeric or categorical values to measure its impact, instead it looks at the impact that an attribute has as a whole. Hence, our model is not aware about which direction is preferred or how an attribute needs to be perturbed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.2">Effectiveness of Shapley values for explainability.</head><p>For our first experiment, we empirically measure the effectiveness of the approximate algorithm in capturing the Shapley values. Given an explainability query, the brute force algorithm produces the exact Shapley values. Since our goal is to capture the exact Shapley values as accurately as possible, we compare these values with the results of various methods. To do this, we considered the top ranked attribute for each algorithm.</p><p>In this experiment, we measure the effectiveness of three methods in explaining the query. These methods are the Shapley values by sampling, the attribute with the highest weight (Section 3.1 ), and the attribute evaluated on the query function independently.</p><p>The datasets for this experiment consists of twelve settings on synthetic data. The settings are each combination of distribution, feature correlation types and scoring function type, i.e. {uniform, Zipfian distribution} Ã— { independent, correlated or anti-correlated features } Ã— { linear, non-linear scoring functions}. For each of these settings, ten trials were run with ğ‘˜ = 5 and the results were recorded. For each experiment, highest rated attribute was removed and the output compared for its impact on the query. For the sampling based approximate Shapley value sample size (ğ‘) of 900 was used. KernelSHAP obtains the same result as sampling based technique with lesser number of samples.</p><p>The results are tabulated in Table <ref type="table" target="#tab_9">7</ref>. The results show that approximate method produced the same output as brute-force in 119 out of the 120 trials. The other methods performed consistently at best equal but generally worse across all queries. Measuring by weight performed almost always better than attribute based baseline. However, measuring by weight still often failed. It had a particularly low accuracy for PQ-NotMatch. Additionally, since weight based approach is not possible for SQ-Multiple, it was considered to be an insufficient method for computing the highest Shapley value.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2.3">User study.</head><p>In this experiment, we conduct a user study to validate our methods. The participants for this user study included working professionals -data analysts, software engineers, and graduate students. A total of 35 people took the user study. The first step of the user study was a quality control step to understand the participants knowledge and confidence in the answers. Among the 35 participants 28 participants showed sufficient knowledge in the control step. Hence, the answers of the remaining 7 participants were disregarded from the user study.</p><p>The goal of the user study is to assess the participant's preference between LIME and Shapley. The user study consisted of two scenarios and a question related to each scenario.</p><p>The first scenario was based on Example 3.1. Participants were provided with the scoring function 5ğ´ 1 + 4ğ´ 2 + ğ´ 3 and told that ğ‘¡ 5 was not selected during the selection process. Participants were provided the explanations from LIME and Shapley value and were asked to select among the two. For the explanation for LIME, we perturb the scores of tuple ğ‘¡ 5 and create a new Boolean variable which measures if ğ‘¡ 5 is present in the top-ğ‘˜ or not (ğ‘˜ = 1). Based on the new dataset, LIME produces an explanation by weighing each of the attributes. In order to explain the meaning of LIME to the user we provide the following statement. "Increasing/Decreasing [FEATURE] by [X] unit contributes [Y] units to ğ‘¡ 5 not being in the top-ğ‘˜, when all other feature values remain fixed". The corresponding explanation for Shapley values is, "The score of [FEATURE] contributed [X] to ğ‘¡ 5 not being in the top-ğ‘˜ compared to the average prediction for the dataset." Among the 28 participants 18 chose Shapley values and the remaining 10 chose LIME.</p><p>For the second scenario, we use the graduate admissions dataset. The scoring function for the graduate admissions dataset was learned using auto-sklearn which generated a ensemble model. We chose a candidate who did not qualify among the top-ğ‘˜ but was very close to the ğ‘˜ ğ‘¡â„ candidate. Similar to the previous scenario, particpants were given a choice between two explanations -LIME and Shapley value. Among the 28 participants, 16 voted in favor of Shapley and 12 in favor of LIME.</p><p>While the votes for the second scenario is close between LIME and Shapley to conclude a clear preference among the participants, for the first scenario the participants preferred the explanation generated by Shapley to be more favorable than LIME.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Performance Evaluation</head><p>Next, we evaluate the approximation error and runtime of samplingbased and KernelSHAP v.s. exact Shapley values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>3.1 Impact of sampling size on error. Approximate samplingbased approach and KernelSHAP provide us with a trade-off between error and time-consumed. As the number of samples increases, the error in Shapley-value decreases, but time increases. We measure the impact of sample size on error and time consumed.</p><p>In this experiment, the number of samples that we use for the approximate Shapley value algorithm and KernelSHAP are varied and the runtime and error are measured. Match list size, ğ‘˜, Table 8: Sample dataset used in Example 1.1. The function weights for the 20 entities are also present as columns within the table.</p><p>is set to 5 for these experiments. Samples for the sampling based algorithm are chosen uniformly, with the sample size varying from 25 to 250 in increments of 25. For this experiment, we consider both, the synthetic datasets and the real world dataset.</p><p>In each experiment setting, we also run the brute force algorithm to obtain exact Shapley values to measure against. For each of the configurations, we aggregate (average) the error across the ğ‘‘ attributes and compute the standard deviation of the errors. The measured average error in Shapley values and standard deviation of the average errors are plotted in Figure <ref type="figure">2</ref> for the Candidates dataset. The time consumed by KernelSHAP and sampling based approach are comparable and far better than the brute force. Among the two approximate techniques, KernelSHAP outperformed the sampling based approach with a similar number of samples as can be seen from the figure. Even though sampling based technique provides us with guarantees on error rate, practically KernelSHAP has a faster convergence rate which can be seen in the smaller variations in the error bars compared to the sampling based approach. Similar results can also be seen for the synthetic dataset with linear (Figure <ref type="figure" target="#fig_4">4</ref>) and non-linear functions (Figure <ref type="figure">3</ref>) .</p><p>Samples Error PQ-Match 50 100 150 200 250 0 0.01 0.02 0.03 0.04 PQ-NotMatch 50 100 150 200 250 0 0.02 0.04 0.06 0.08 SQ-Single 50 100 150 200 250 0 0.005 0.01 0.015 0.02 SQ-Multiple 50 100 150 200 250 0 0.01 0.02 0.03 0.04 AC Zipf Sampling AC Zipf KernelSHAP C Zipf Sampling C Zipf KernelSHAP I Zipf Sampling I Zipf KernelSHAP Figure 3: Error variations in sampling-based approach and KernelSHAP when varying number of samples for synthetic dataset with non-linear ranking functions Samples Error PQ-Match 50 100 150 200 250 0 0.02 0.04 0.06 PQ-NotMatch 50 100 150 200 250 0 0.02 0.04 0.06 SQ-Single 50 100 150 200 250 0 0.005 0.01 0.015 SQ-Multiple 50 100 150 200 250 0 0.02 0.04 0.06 AC Zipf Sampling AC Zipf KernelSHAP C Zipf Sampling C Zipf KernelSHAP I Zipf Sampling I Zipf KernelSHAP and KernelSHAP. Sampling based approach and KernelSHAP both use 100 samples in this experiment. For this experiment, we vary the number of dimensions from 4 to 128. We measure the amount of time taken and error of the Shapley values by the Exact, Sampling-based Approximate and KernelSHAP. As the Shapley values is a vector, the error is measured as the â„“ 2 norm of difference between the Shapley values of Exact and approximate methods. We limit the time of each configuration to 10 minutes. As the Exact approach consumes exponential amount of time with respect to ğ‘‘, computing the Exact Shapley values for larger dimensions is expensive.</p><p>Figure <ref type="figure">5a</ref> shows the time consumed by Exact, Sampling and KernelSHAP as we vary the number of dimensions. Due to the 10 minute time limit on each configuration of this experiment, the expensive Exact approach exceeds the time limits for ğ‘‘ &gt; 11. For similar number of samples, KernelSHAP and Sampling consumes similar amount of time, with Sampling consuming slightly lesser amount of time. The error incurred during the computation of Sampling and KernelSHAP is shown in Figure <ref type="figure">5b</ref>. As can be seen, KernelSHAP outperforms Sampling based technique in terms of error. While the plots for KernelSHAP and Sampling seem to overlap as the number of dimensions increases, the values for larger dimensions also show that KernelSHAP slightly performs better than Sampling based technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RELATED WORK</head><p>Matching and applications. Matching plays a critical role in the allocation of resources based on supply and demand like matching a region to medical needs <ref type="bibr" target="#b17">[18]</ref>, ecosystem services are matched based on changing land use <ref type="bibr" target="#b0">[1]</ref>, public health needs are matched by health insurance plans <ref type="bibr" target="#b1">[2]</ref>. Matching systems rely on different mechanisms to capture preferences the users. Traditionally, these preferences are explicitly specified <ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref><ref type="bibr" target="#b20">[21]</ref><ref type="bibr" target="#b21">[22]</ref>.</p><p>Explicitly specified matching relies on capturing preference lists from both the parties and then create a stable matching under specific conditions. Based on game theory, Gale and Shapley <ref type="bibr" target="#b22">[23]</ref> designed a mathematical framework to attain stable matching and applied it to stable marriage and college admission. Such matching where one party is matched only to one other party is known as stable marriage <ref type="bibr" target="#b23">[24]</ref><ref type="bibr" target="#b24">[25]</ref><ref type="bibr" target="#b25">[26]</ref>. Similarly, many-toone stable matching exists with applications such as: hospitals provide employment to many doctors <ref type="bibr" target="#b26">[27]</ref> or student-project allocations <ref type="bibr" target="#b27">[28]</ref> which was formalized by Roth and Sotomayor <ref type="bibr" target="#b28">[29]</ref>. Many-to-many stable matching relies on matching many supply parties to many demand parties, which has applications in D2D-enabled cellular networks <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b29">30]</ref>, collaborator recommendations <ref type="bibr" target="#b30">[31]</ref>. While there has been extensive work on explicit matching, to the best of our knowledge there has not been any explain-ability work in these fields.</p><p>Often, specifying the complete preference list is prohibitive in big data applications <ref type="bibr" target="#b31">[32]</ref>. In such cases, the preference can be obtained via different means. In case of a search engine, users interact with the search engine to express their query until they reach their desired result (web-page). Traditionally TF-IDF <ref type="bibr" target="#b32">[33,</ref><ref type="bibr" target="#b33">34]</ref> and Latent Semantic Analysis <ref type="bibr" target="#b34">[35,</ref><ref type="bibr" target="#b35">36]</ref> based approaches were proposed to solve this problem. Recently, vector representation based approaches <ref type="bibr" target="#b36">[37,</ref><ref type="bibr" target="#b37">38]</ref> convert words into vector form and then use this embedded space representation to process the query. Another type of application where implicit preference is seen is user-item recommendation systems like Amazon<ref type="foot" target="#foot_3">foot_3</ref> , Netflix <ref type="foot" target="#foot_4">8</ref> . In user-item recommendation systems, items are recommended with prior interactions of the user with their systems. Numerous techniques like collaborative filtering <ref type="bibr" target="#b38">[39]</ref>, matrix factorisation <ref type="bibr" target="#b39">[40]</ref>, auto encoder based representations <ref type="bibr" target="#b40">[41,</ref><ref type="bibr" target="#b41">42]</ref> have been proposed to solve the problem. While some of these works have explanations built within the system <ref type="bibr" target="#b42">[43,</ref><ref type="bibr" target="#b43">44]</ref>, to the best of our knowledge we are the first to work on explanations in bipartite matching scenarios.</p><p>Explainability in top-ğ‘˜ and ranking. Ranking functions are popular for solving multi-criteria optimization. While ranking functions have been studied for many years, study of explainability in ranking has been a recent trend. Verma et al. <ref type="bibr" target="#b44">[45]</ref> explain queries based on a sampling approach in the neighbourhood of the query. Gale and Marian explore the topic of explaining ranking in multiple papers. First, in their 2019 paper <ref type="bibr" target="#b45">[46]</ref> they assign scores to various attributes based on whether the items in the top-ğ‘˜ for all methods are in the top-ğ‘˜ for a particular attribute. They also demonstrate that the explanation for a ranking can be used to adjust a ranking function such that attributes are contributing to the amount required. The main difference between their work and ours is that they use this as an explanation for ranking. Top-k is similar but independent from ranking, and additionally our matching are bipartite. The difference is further shown by the fact that these algorithms cannot be easily modified to work for our queries. Next in 2020 <ref type="bibr" target="#b46">[47]</ref>, Gale and Marian expand upon their initial observations by also considering the weight of different parameters, and considering multiple metrics for the type of ranking produced by the function, namely disparity diversity. Diversity and disparity in ranking has also been studied by works like <ref type="bibr" target="#b47">[48]</ref>. Additionally, some work has been done on responsible ranking function design <ref type="bibr" target="#b47">[48,</ref><ref type="bibr" target="#b48">49]</ref>, where the objective is to minimally change the weights in a ranking function to make the generated rankings (top-ğ‘˜) fair and stable.</p><p>Why not questions over database queries answer why a certain tuple was not present in the database query output. They were first studied by Chapman and Jagadish <ref type="bibr" target="#b49">[50]</ref> followed by a rich field of work known as why or why-not provenance <ref type="bibr" target="#b50">[51]</ref><ref type="bibr" target="#b51">[52]</ref><ref type="bibr" target="#b52">[53]</ref><ref type="bibr" target="#b53">[54]</ref><ref type="bibr" target="#b54">[55]</ref>. While why-not query tries to explain why a tuple is not present in the query result, our problem looks at a black-box matching system. The notion of why not was extended to top-ğ‘˜ queries by He et. al. <ref type="bibr" target="#b55">[56]</ref> where the problem is to find why a certain tuple is not present in the given top-ğ‘˜ query. They also propose an approach to modify the query slightly such that the query data-point is present in the top-ğ‘˜ query. Gao et. al. <ref type="bibr" target="#b56">[57]</ref> propose the problem of why not for reverse top-ğ‘˜ queries and also propose modifications to accommodate the point into the top-ğ‘˜. The notion of why-not was further extended by Chen et. al. <ref type="bibr" target="#b57">[58]</ref> to why not yet where the potential solution included modifying the query weights, or ğ‘˜ slightly to include the query tuple in the top-ğ‘˜. However, there are two fundamental ways in which our work differs from this body of work. All these papers assume (a) linear ranking functions, and (b) the functions themselves are "white boxes", i..e, the weights are known. In contrast, our paper focuses on black box ranking functions, and moreover, these functions do not have to be linear. All we assume is that the attributes in our functions can be masked to observe how their behavior changes. Islam et. al <ref type="bibr" target="#b58">[59]</ref> propose the problem of answering why-not queries over reverse skyline and dynamic skyline queries. A key difference between our work and <ref type="bibr" target="#b58">[59]</ref> is that skyline can be used to find the top-1 over the set of monotone functions. While for a tuple to appear in the skyline it suffices to be in the top-1 of one (any) of the functions in the set, we are interested in a specific (query) function. Additionally, the notion of match list in matching deals with top-ğ‘˜.</p><p>Shapley values for explanations. Shapley values were introduced by <ref type="bibr">Gale Shapley [7]</ref> to determine the contribution of each player to the success of the overall coalition. Shapley values have also been applied to the problem of explanations with a great degree of success. Here, the contribution of the various features to the overall prediction are calculated as Shapley values, and the Shapley values are used to explain the task <ref type="bibr" target="#b59">[60]</ref>. Several notable contributions have been made to this. Å trumbelj et al. <ref type="bibr" target="#b8">[9]</ref> devise a Monte Carlo sampling technique for explaining models, in order to avoid the exponential nature of exact Shapley value computation. Lundberg et al. <ref type="bibr" target="#b9">[10]</ref> mapped the notion of Shapley values to the problem of model interpretability, introducing SHAP and specifically KernelSHAP which allows for regression-based, model agnostic computation of SHAP values. Lundberg et al. expand upon this notion in 2018 <ref type="bibr" target="#b60">[61]</ref> with the TreeSHAP method, which is capable of computing SHAP values for tree based models in polynomial time. While these methods have been studied extensively in machine learning, the problem of explainability in bipartite matching is novel. Kumar et al. <ref type="bibr" target="#b12">[13]</ref> have shown certain limitations of Shapley-based methods while explaining machine learning models. The limitations highlighted during the process include (i) out-of-distribution points generated during the masking process, (ii) explanations using Shapley are not actionable. We emphasise that bipartite matching is not subject to similar problems due to competition. Nevertheless, we have added a note about improper handling of NULL values during masking process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">FINAL REMARKS</head><p>The concept of match list is modelled on real world matching websites and applications. Some more practical models may include more complex scenarios which can extend to more data types like non-binary matching values, matching preferences that extend to multiple matching values, probabilistic modelling of preference functions. While we present four different explainability queries that may be encountered in real life, there may be many more of these queries which may be of interest. We consider both these extensions important, and an avenue for future work.</p><p>While the model we propose is based on the real world, one might also want to consider other theoretical models of matching, like a complete ranked list by each individual instead of ranking functions. These lists could then be used in a stable marriage algorithm to produce a matching. Such alternate models which may be of theoretical interest can be considered as alternate models and present an opportunity for a thorough theoretical analysis.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Example 3 . 1 .</head><label>31</label><figDesc>(Part 1) Consider a sample dataset D with 3 attributes A = {ğ´ 1 , ğ´ 2 , ğ´ 3 } and 5 entities, shown in Table</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>3. 3 . 5</head><label>35</label><figDesc>Time complexity analysis. Theorem 3.2 shows the time taken to compute the exact Shapley value is exponential to the number of attributes for all the four queries, making Exact Shapley value computation impractical when ğ‘‘ is not small. Theorem 3.2. Given a dataset D with ranking functions ğ¹ with the other parameters for PQ-NotMatch, PQ-Match, SQ-Single and SQ-Multiple, computing the exact Shapley value takes exponential time to number of the players (attributes).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Theorem 3 . 3 .</head><label>33</label><figDesc>Given an approximation bound ğ›¼ and error rate ğœ–, sampling ğ‘ â‰¥ 2 log (2/ğœ– ) ğ›¼ 2 random permutation members of the symmetric group, ensures that the inequality ğ‘ƒğ‘Ÿ (| Åœâ„ ğ‘– -ğ‘†â„ ğ‘– | &lt; ğ›¼) &gt; 1 -ğœ– is satisfied for all four problems.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>4. 1 . 5 Figure 2 :</head><label>152</label><figDesc>Figure 2: Error variations in sampling-based approach and KernelSHAP</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Error variations in sampling-based approach and KernelSHAP when varying number of samples for synthetic dataset with linear ranking functions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>The generated explanation for why Candidate ğ‘¡ 3 is not in the Top-K of HR ğ‘¡ 20</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Python</cell><cell>R</cell><cell>PHP</cell><cell>JS</cell></row><row><cell cols="2">Candidates</cell><cell></cell><cell></cell><cell>Candidate Attribute Values HR Attribute Values</cell><cell>2 3</cell><cell>2 2</cell><cell>1 0</cell><cell>1 2</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>HR Ranking Weights</cell><cell>0.11</cell><cell>0.44 0.33 0.11</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>Shapley Values</cell><cell>0.25</cell><cell>0.91 -0.08 -0.08</cell></row><row><cell>HRs</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="5">Figure 1: Sample bipartite graph for Example 1.1</cell><cell></cell></row><row><cell cols="2">Python</cell><cell>R</cell><cell>PHP</cell><cell>JS</cell><cell></cell></row><row><cell>Candidate Attribute Values</cell><cell>2</cell><cell>2</cell><cell>1</cell><cell>1</cell><cell></cell></row><row><cell>HR Attribute Values</cell><cell>2</cell><cell>2</cell><cell>0</cell><cell>3</cell><cell></cell></row><row><cell>HR Ranking Weights</cell><cell>0.11</cell><cell cols="3">0.11 0.67 0.11</cell><cell></cell></row><row><cell>Shapley Values</cell><cell>0</cell><cell cols="3">-0.16 0.83 0.33</cell><cell></cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>The generated explanation for why Candidate ğ‘¡ 3 is in the Top-K of HR ğ‘¡ 19</figDesc><table><row><cell></cell><cell>Python</cell><cell>R</cell><cell>PHP</cell><cell>JS</cell></row><row><cell>Candidate Attribute Values</cell><cell>2</cell><cell>2</cell><cell>1</cell><cell>1</cell></row><row><cell>Candidate Ranking Weights</cell><cell>0.84</cell><cell cols="3">0.02 0.06 0.08</cell></row><row><cell>Shapley Values</cell><cell>0.61</cell><cell cols="3">0.28 0.0 0.11</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>The generated explanation for why Candidate ğ‘¡ 3 's Top-K looks the way it does.</figDesc><table><row><cell></cell><cell>Python</cell><cell>R</cell><cell>PHP</cell><cell>JS</cell></row><row><cell>Candidate Attribute Values</cell><cell>2</cell><cell>2</cell><cell>1</cell><cell>1</cell></row><row><cell>Shapley Values</cell><cell>0.48</cell><cell cols="3">0.23 0.33 0.15</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 5 :</head><label>5</label><figDesc>ğ‘“ (ğ‘¡ ğ‘– ) 62 25.4 81.8 54.5 81.7 (Example 3.1) A sample dataset D with three attributes ğ´ 1 , ğ´ 2 and ğ´ 3 , and 5 entities.value of ğ‘˜ be equal to 2. The linear ranking function scores the entities ğ‘¡ 1 , ğ‘¡ 2 , ğ‘¡ 3 , ğ‘¡ 4 and ğ‘¡ 5 with scores 62 , 25.4, 81.8, 54.5, and 81.7, respectively. The entities ranked by their scores are ğ‘¡ 3 , ğ‘¡ 5 , ğ‘¡ 1 , ğ‘¡ 4 and ğ‘¡ 2 .</figDesc><table><row><cell></cell><cell>ğ‘¡ 1</cell><cell>ğ‘¡ 2</cell><cell>ğ‘¡ 3</cell><cell>ğ‘¡ 4</cell><cell>ğ‘¡ 5</cell><cell>weights</cell></row><row><cell>ğ´ 1</cell><cell>10</cell><cell>1.2</cell><cell>9</cell><cell>9.5</cell><cell>10.1</cell><cell>5</cell></row><row><cell>ğ´ 2</cell><cell>1</cell><cell>1.1</cell><cell>1.2</cell><cell>1.5</cell><cell>1.8</cell><cell>4</cell></row><row><cell>ğ´ 3</cell><cell>8</cell><cell>15</cell><cell>32</cell><cell>1</cell><cell>24</cell><cell>1</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8"><head>Table 6 :</head><label>6</label><figDesc>Candidate values, HR rankings, and PQ-NotMatch Shapley values.company would like to see more skill in R, CSS, and React.js specifically. The company was overall pleased with your Grade 10, Grade 12, and Post-grad Performance, but considering all factors, they did not want to match with you at this time."</figDesc><table><row><cell></cell><cell>Candiate Values</cell><cell cols="2">HR Function Shapley Values</cell></row><row><cell>Python</cell><cell>1.0</cell><cell>0.002</cell><cell>0.0</cell></row><row><cell>R</cell><cell>0.0</cell><cell>0.005</cell><cell>0.09</cell></row><row><cell>Deep Learning</cell><cell>0.333</cell><cell>0.005</cell><cell>0.025</cell></row><row><cell>PHP</cell><cell>0.667</cell><cell>0.007</cell><cell>0.05</cell></row><row><cell>MySQL</cell><cell>0.667</cell><cell>0.007</cell><cell>0.075</cell></row><row><cell>HTML</cell><cell>0.667</cell><cell>0.007</cell><cell>0.035</cell></row><row><cell>CSS</cell><cell>0.0</cell><cell>0.005</cell><cell>0.085</cell></row><row><cell>JavaScript</cell><cell>0.667</cell><cell>0.005</cell><cell>0.065</cell></row><row><cell>AJAX</cell><cell>0.0</cell><cell>0.005</cell><cell>0.06</cell></row><row><cell>Bootstrap</cell><cell>0.0</cell><cell>0.006</cell><cell>0.07</cell></row><row><cell>MongoDB</cell><cell>0.0</cell><cell>0.005</cell><cell>0.045</cell></row><row><cell>Node.js</cell><cell>0.0</cell><cell>0.003</cell><cell>0.045</cell></row><row><cell>Reactjs</cell><cell>0.0</cell><cell>0.005</cell><cell>0.09</cell></row><row><cell>Performance_PG</cell><cell>0.791</cell><cell>0.06</cell><cell>-0.02</cell></row><row><cell cols="2">Performance_UG 0.7</cell><cell>0.06</cell><cell>0.015</cell></row><row><cell>Performance_12</cell><cell>1.0</cell><cell>0.06</cell><cell>-0.05</cell></row><row><cell>Performance_10</cell><cell>1.0</cell><cell>0.120</cell><cell>-0.05</cell></row><row><cell>Other Skills</cell><cell>['Algorithms', 'Data Structures', ...]</cell><cell>0.0769</cell><cell>0.065</cell></row><row><cell>Degree</cell><cell>Master of Science</cell><cell>0.0769</cell><cell>0.21</cell></row><row><cell>Stream</cell><cell>Computer Science</cell><cell>0.0769</cell><cell>0.05</cell></row><row><cell>Grad Year</cell><cell>2018</cell><cell>0.307</cell><cell>0.04</cell></row><row><cell>Current City</cell><cell>Bangalore</cell><cell>0.0769</cell><cell>0.005</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_9"><head>Table 7 :</head><label>7</label><figDesc>The success measure of four methods in computing the same top value as Brute Force; APX=Approximate, WT=Weight, SCR=Attribute Score; and the four queries, Q1-Q4. For Q4, WT could not be used.</figDesc><table><row><cell></cell><cell cols="3">Functions weights</cell><cell></cell><cell></cell><cell>A</cell><cell></cell><cell></cell></row><row><cell></cell><cell>Python</cell><cell>R</cell><cell>PHP</cell><cell>JS</cell><cell>Python</cell><cell>R</cell><cell>PHP</cell><cell>JS</cell></row><row><cell>ğ‘¡ 1</cell><cell>0.83</cell><cell cols="3">0.03 0.1 0.03</cell><cell>0</cell><cell cols="3">0.67 0.67 0.67</cell></row><row><cell>ğ‘¡ 2</cell><cell>0.33</cell><cell cols="3">0.11 0.22 0.33</cell><cell>1</cell><cell>0.33</cell><cell>0</cell><cell>0</cell></row><row><cell>ğ‘¡ 3</cell><cell>0.84</cell><cell cols="3">0.02 0.06 0.08</cell><cell>0.67</cell><cell cols="3">0.67 0.33 0.33</cell></row><row><cell>ğ‘¡ 4</cell><cell>0.09</cell><cell cols="3">0.09 0.64 0.18</cell><cell>0.67</cell><cell cols="2">0.67 0.67</cell><cell>0</cell></row><row><cell>ğ‘¡ 5</cell><cell>0.29</cell><cell cols="3">0.14 0.14 0.43</cell><cell>0.67</cell><cell>0</cell><cell>0</cell><cell>0</cell></row><row><cell>ğ‘¡ 6</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0.99</cell><cell>0.67</cell><cell>0</cell><cell>0.67</cell><cell>0</cell></row><row><cell>ğ‘¡ 7</cell><cell>0</cell><cell cols="3">0.97 0.01 0.02</cell><cell>0.67</cell><cell>0</cell><cell cols="2">0.67 0.67</cell></row><row><cell>ğ‘¡ 8</cell><cell>0.68</cell><cell cols="3">0.05 0.05 0.23</cell><cell>0.33</cell><cell>0</cell><cell cols="2">0.67 0.67</cell></row><row><cell>ğ‘¡ 9</cell><cell>0.17</cell><cell cols="3">0.17 0.17 0.50</cell><cell>0.67</cell><cell>0</cell><cell>0</cell><cell>0.67</cell></row><row><cell>ğ‘¡ 10</cell><cell>0.12</cell><cell cols="3">0.04 0.12 0.71</cell><cell>0.67</cell><cell>0</cell><cell>0</cell><cell>0.33</cell></row><row><cell>ğ‘¡ 11</cell><cell>0</cell><cell cols="3">0.23 0.18 0.59</cell><cell>0</cell><cell>1</cell><cell>1</cell><cell>1</cell></row><row><cell>ğ‘¡ 12</cell><cell>0</cell><cell>0</cell><cell>1</cell><cell>0.00</cell><cell>0</cell><cell>0.67</cell><cell>1</cell><cell>1</cell></row><row><cell>ğ‘¡ 13</cell><cell>0.2</cell><cell>0.3</cell><cell cols="2">0.4 0.10</cell><cell>1</cell><cell>0.33</cell><cell>0</cell><cell>1</cell></row><row><cell>ğ‘¡ 14</cell><cell>0.29</cell><cell cols="3">0.14 0.43 0.14</cell><cell>0</cell><cell>1</cell><cell>0.33</cell><cell>1</cell></row><row><cell>ğ‘¡ 15</cell><cell>0.01</cell><cell cols="3">0.01 0.09 0.89</cell><cell>0</cell><cell>1</cell><cell>0.67</cell><cell>0</cell></row><row><cell>ğ‘¡ 16</cell><cell>0.7</cell><cell>0.1</cell><cell cols="2">0.1 0.10</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>0</cell></row><row><cell>ğ‘¡ 17</cell><cell>0</cell><cell>0</cell><cell cols="2">0.98 0.01</cell><cell>0</cell><cell>0</cell><cell>0</cell><cell>1</cell></row><row><cell>ğ‘¡ 18</cell><cell>0</cell><cell>0</cell><cell>1</cell><cell>0.00</cell><cell>0.33</cell><cell>1</cell><cell>0.67</cell><cell>1</cell></row><row><cell>ğ‘¡ 19</cell><cell>0.11</cell><cell cols="3">0.44 0.33 0.11</cell><cell>1</cell><cell>0.67</cell><cell>0</cell><cell>0.67</cell></row><row><cell>ğ‘¡ 20</cell><cell>0.11</cell><cell cols="3">0.11 0.67 0.11</cell><cell>0.67</cell><cell>0.67</cell><cell>0</cell><cell>1</cell></row></table></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="4" xml:id="foot_0"><p>https://www.kaggle.com/datasets/saikrishna20/candidates-list</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="5" xml:id="foot_1"><p>Code can be accessed at https://github.com/UIC-InDeXLab/ExplainMatchTopK</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="6" xml:id="foot_2"><p>https://github.com/slundberg/shap</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="7" xml:id="foot_3"><p>https://www.amazon.com/</p></note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="8" xml:id="foot_4"><p>https://www.netflix.com/</p></note>
		</body>
		<back>

			<div type="acknowledgement">
<div><head n="7">ACKNOWLEDGEMENTS</head><p>The work of <rs type="person">Gautam Das</rs> was supported in part by grants <rs type="funder">NSF</rs> <rs type="grantNumber">2107296</rs> and <rs type="grantNumber">NSF 2008602</rs> from the <rs type="funder">National Science Foundation</rs>. The work of <rs type="person">Abolfazl Asudeh</rs> was supported in part by grant <rs type="funder">NSF</rs> <rs type="grantNumber">2107290</rs> from the <rs type="funder">National Science Foundation</rs>.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_map8teG">
					<idno type="grant-number">2107296</idno>
				</org>
				<org type="funding" xml:id="_qUAHCUR">
					<idno type="grant-number">NSF 2008602</idno>
				</org>
				<org type="funding" xml:id="_3vmYKNQ">
					<idno type="grant-number">2107290</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Distribution Correlation</head><p>Function APX -Q1 APX -Q2 APX -Q3 APX -Q4 WT -Q1 WT -Q2 WT -Q3 SCR -Q1 SCR -Q2 SCR -Q3 SCR -Q4 </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A backcasting approach for matching regional ecosystem services supply and demand</title>
		<author>
			<persName><forename type="first">Sibyl</forename><forename type="middle">Hanna</forename><surname>Brunner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><surname>Huber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Adrienne</forename><surname>GrÃªt-Regamey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Environmental Modelling &amp; Software</title>
		<imprint>
			<biblScope unit="volume">75</biblScope>
			<biblScope unit="page" from="439" to="458" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Matching Supply and Demand</title>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">D</forename><surname>Lieberthal</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
			<publisher>Springer International Publishing</publisher>
			<biblScope unit="page" from="145" to="171" />
			<pubPlace>Cham</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Matching supply and demand: A typology of climate services</title>
		<author>
			<persName><forename type="first">Klaasjan</forename><surname>Visscher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Peter</forename><surname>Stegmaier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Andrea</forename><surname>Damm</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robin</forename><surname>Hamaker-Taylor</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Atte</forename><surname>Harjanne</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Raffaele</forename><surname>Giordano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Climate Services</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page">100136</biblScope>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Recommendation systems for markets with two sided preferences</title>
		<author>
			<persName><forename type="first">Anjan</forename><surname>Goswami</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fares</forename><surname>Hedayati</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Prasant</forename><surname>Mohapatra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2014 13th International Conference on Machine Learning and Applications</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="282" to="287" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Fairrec: Two-sided fairness for personalized recommendations in two-sided platforms</title>
		<author>
			<persName><forename type="first">Arpita</forename><surname>Gourab K Patro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Niloy</forename><surname>Biswas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Krishna</forename><forename type="middle">P</forename><surname>Ganguly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Abhijnan</forename><surname>Gummadi</surname></persName>
		</author>
		<author>
			<persName><surname>Chakraborty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the web conference 2020</title>
		<meeting>the web conference 2020</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="1194" to="1204" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Two-sided internet platforms: A business model lifecycle perspective</title>
		<author>
			<persName><forename type="first">Laurent</forename><surname>Muzellec</surname></persName>
		</author>
		<author>
			<persName><forename type="first">SÃ©bastien</forename><surname>Ronteau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mary</forename><surname>Lambkin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Industrial Marketing Management</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="139" to="150" />
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName><forename type="first">Lloyd</forename><forename type="middle">S</forename><surname>Shapley</surname></persName>
		</author>
		<title level="m">A value for n-person games</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="1988">1988</date>
			<biblScope unit="page" from="31" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Feature relevance quantification in explainable ai: A causal problem</title>
		<author>
			<persName><forename type="first">Dominik</forename><surname>Janzing</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lenon</forename><surname>Minorics</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Patrick</forename><surname>BlÃ¶baum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on artificial intelligence and statistics</title>
		<imprint>
			<publisher>PMLR</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="2907" to="2916" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Explaining prediction models and individual predictions with feature contributions</title>
		<author>
			<persName><forename type="first">Erik</forename><surname>Å trumbelj</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Igor</forename><surname>Kononenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Knowledge and information systems</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="647" to="665" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A unified approach to interpreting model predictions</title>
		<author>
			<persName><forename type="first">M</forename><surname>Scott</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Su-In</forename><surname>Lundberg</surname></persName>
		</author>
		<author>
			<persName><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in neural information processing systems</title>
		<imprint>
			<biblScope unit="volume">30</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Query reranking as a service</title>
		<author>
			<persName><forename type="first">Abolfazl</forename><surname>Asudeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nan</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gautam</forename><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="888" to="899" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Fairly evaluating and scoring items in a data set</title>
		<author>
			<persName><forename type="first">Abolfazl</forename><surname>Asudeh</surname></persName>
		</author>
		<author>
			<persName><surname>Jagadish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="3445" to="3448" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Problems with shapley-value-based explanations as feature importance measures</title>
		<author>
			<persName><forename type="first">Elizabeth</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Suresh</forename><surname>Venkatasubramanian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Scheidegger</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sorelle</forename><surname>Friedler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Machine Learning</title>
		<imprint>
			<publisher>PMLR</publisher>
			<date type="published" when="2020">2020</date>
			<biblScope unit="page" from="5491" to="5500" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A linear approximation method for the shapley value</title>
		<author>
			<persName><forename type="first">Michael</forename><surname>Shaheen S Fatima</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nicholas</forename><forename type="middle">R</forename><surname>Wooldridge</surname></persName>
		</author>
		<author>
			<persName><surname>Jennings</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Artificial Intelligence</title>
		<imprint>
			<biblScope unit="volume">172</biblScope>
			<biblScope unit="issue">14</biblScope>
			<biblScope unit="page" from="1673" to="1699" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Probability inequalities for sums of bounded random variables</title>
		<author>
			<persName><forename type="first">Wassily</forename><surname>Hoeffding</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The collected works of Wassily Hoeffding</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1994">1994</date>
			<biblScope unit="page" from="409" to="426" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">why should i trust you?&quot; explaining the predictions of any classifier</title>
		<author>
			<persName><forename type="first">Marco</forename><surname>Tulio Ribeiro</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Sameer</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Carlos</forename><surname>Guestrin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM SIGKDD international conference on knowledge discovery and data mining</title>
		<meeting>the 22nd ACM SIGKDD international conference on knowledge discovery and data mining</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1135" to="1144" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A comparison of regression models for prediction of graduate admissions</title>
		<author>
			<persName><forename type="first">Asfia</forename><surname>Mohan S Acharya</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aneeta S</forename><surname>Armaan</surname></persName>
		</author>
		<author>
			<persName><surname>Antony</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2019 international conference on computational intelligence in data science (ICCIDS)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1" to="5" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Supply-demand matching of medical services at a city level under the background of hierarchical diagnosis and treatment-based on didi chuxing data in haikou, china</title>
		<author>
			<persName><forename type="first">Haiyan</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Cheng</forename><surname>Jin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jing</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yexi</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bing</forename><surname>Xu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">BMC Health Services Research</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="12" />
			<date type="published" when="2022">2022</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Stable matching in large economies</title>
		<author>
			<persName><forename type="first">Yeon-Koo</forename><surname>Che</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jinwoo</forename><surname>Kim</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Fuhito</forename><surname>Kojima</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Econometrica</title>
		<imprint>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="65" to="110" />
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Stable matching for wireless urllc in multi-cellular, multi-user systems</title>
		<author>
			<persName><forename type="first">Tom</forename><surname>HÃ¶ÃŸler</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Philipp</forename><surname>Schulz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eduard</forename><forename type="middle">A</forename><surname>Jorswieck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Meryem</forename><surname>Simsek</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerhard</forename><forename type="middle">P</forename><surname>Fettweis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Communications</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="5228" to="5241" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Matching markets: Theory and practice</title>
		<author>
			<persName><forename type="first">Atila</forename><surname>Abdulkadiroglu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Tayfun</forename><surname>SÃ¶nmez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in Economics and Econometrics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="3" to="47" />
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Experiments on matching markets: A survey</title>
		<author>
			<persName><forename type="first">Rustamdjan</forename><surname>Hakimov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dorothea</forename><surname>KÃ¼bler</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
	<note type="report_type">WZB Discussion Paper</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">College admissions and the stability of marriage</title>
		<author>
			<persName><forename type="first">David</forename><surname>Gale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lloyd</forename><forename type="middle">S</forename><surname>Shapley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The American Mathematical Monthly</title>
		<imprint>
			<biblScope unit="volume">69</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="9" to="15" />
			<date type="published" when="1962">1962</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
		<title level="m" type="main">Handbook of game theory with economic applications</title>
		<author>
			<persName><forename type="first">Alvin</forename><forename type="middle">E</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marilda</forename><surname>Sotomayor</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992">1992</date>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="485" to="541" />
		</imprint>
	</monogr>
	<note>Two-sided matching</note>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">A theory of marriage: Part i</title>
		<author>
			<persName><forename type="first">S</forename><surname>Gary</surname></persName>
		</author>
		<author>
			<persName><surname>Becker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Political economy</title>
		<imprint>
			<biblScope unit="volume">81</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="813" to="846" />
			<date type="published" when="1973">1973</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Courtship as a waiting game</title>
		<author>
			<persName><forename type="first">C</forename><surname>Theodore</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mark</forename><surname>Bergstrom</surname></persName>
		</author>
		<author>
			<persName><surname>Bagnoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of political economy</title>
		<imprint>
			<biblScope unit="volume">101</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="185" to="202" />
			<date type="published" when="1993">1993</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Multi-objective optimization models for many-to-one matching problems</title>
		<author>
			<persName><forename type="first">Natsumi</forename><surname>Shimada</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Natsuki</forename><surname>Yamazaki</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yuichi</forename><surname>Takano</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Information Processing</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="406" to="412" />
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Two algorithms for the student-project allocation problem</title>
		<author>
			<persName><forename type="first">J</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Robert</forename><forename type="middle">W</forename><surname>Abraham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">David</forename><forename type="middle">F</forename><surname>Irving</surname></persName>
		</author>
		<author>
			<persName><surname>Manlove</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of discrete algorithms</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="73" to="90" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The college admissions problem revisited</title>
		<author>
			<persName><forename type="first">Alvin</forename><forename type="middle">E</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Marilda</forename><surname>Sotomayor</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Econometrica: Journal of the Econometric Society</title>
		<imprint>
			<biblScope unit="page" from="559" to="570" />
			<date type="published" when="1989">1989</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Many-to-many matching for social-aware minimized redundancy caching in d2d-enabled cellular networks</title>
		<author>
			<persName><forename type="first">Shenshen</forename><surname>Qian</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bowen</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Song</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yanjing</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yi</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jingjing</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Networks</title>
		<imprint>
			<biblScope unit="volume">175</biblScope>
			<biblScope unit="page">107249</biblScope>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Many-to-many collaborator recommendation based on matching markets theory</title>
		<author>
			<persName><forename type="first">Xiangjie</forename><surname>Kong</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Linyan</forename><surname>Wen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jing</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mingliang</forename><surname>Hou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Minghao</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feng</forename><surname>Xia</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Intl Conf on Dependable, Autonomic and Secure Computing, Intl Conf on Pervasive Intelligence and Computing, Intl Conf on Cloud and Big Data Computing, Intl Conf on Cyber Science and Technology Congress (DASC/PiCom/CBDCom/CyberSciTech)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2019">2019. 2019</date>
			<biblScope unit="page" from="109" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Matching algorithms: fundamentals, applications and challenges</title>
		<author>
			<persName><forename type="first">Jing</forename><surname>Ren</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Feng</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiangtai</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jiaying</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mingliang</forename><surname>Hou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Ahsan</forename><surname>Shehzad</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Nargiz</forename><surname>Sultanova</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiangjie</forename><surname>Kong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Emerging Topics in Computational Intelligence</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="332" to="350" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Using tf-idf to determine word relevance in document queries</title>
		<author>
			<persName><forename type="first">Juan</forename><surname>Ramos</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the first instructional conference on machine learning</title>
		<meeting>the first instructional conference on machine learning</meeting>
		<imprint>
			<publisher>Citeseer</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="volume">242</biblScope>
			<biblScope unit="page" from="29" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Term-weighting approaches in automatic text retrieval</title>
		<author>
			<persName><forename type="first">Gerard</forename><surname>Salton</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Buckley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Information processing &amp; management</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="513" to="523" />
			<date type="published" when="1988">1988</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Latent semantic analysis</title>
		<author>
			<persName><forename type="first">Susan</forename><forename type="middle">T</forename><surname>Dumais</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annu. Rev. Inf. Sci. Technol</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="188" to="230" />
			<date type="published" when="2004">2004</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Probabilistic latent semantic indexing</title>
		<author>
			<persName><forename type="first">Thomas</forename><surname>Hofmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd annual international ACM SIGIR conference on Research and development in information retrieval</title>
		<meeting>the 22nd annual international ACM SIGIR conference on Research and development in information retrieval</meeting>
		<imprint>
			<date type="published" when="1999">1999</date>
			<biblScope unit="page" from="50" to="57" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Learning deep structured semantic models for web search using clickthrough data</title>
		<author>
			<persName><forename type="first">Po-Sen</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaodong</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianfeng</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alex</forename><surname>Acero</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Larry</forename><surname>Heck</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 22nd ACM international conference on Information &amp; Knowledge Management</title>
		<meeting>the 22nd ACM international conference on Information &amp; Knowledge Management</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
			<biblScope unit="page" from="2333" to="2338" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">A latent semantic model with convolutional-pooling structure for information retrieval</title>
		<author>
			<persName><forename type="first">Yelong</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Xiaodong</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Jianfeng</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Li</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">GrÃ©goire</forename><surname>Mesnil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd ACM international conference on conference on information and knowledge management</title>
		<meeting>the 23rd ACM international conference on conference on information and knowledge management</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="101" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">A survey of collaborative filtering techniques</title>
		<author>
			<persName><forename type="first">Xiaoyuan</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Taghi</surname></persName>
		</author>
		<author>
			<persName><surname>Khoshgoftaar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in artificial intelligence</title>
		<imprint>
			<date type="published" when="2009">2009. 2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Regularizing matrix factorization with user and item embeddings for recommendation</title>
		<author>
			<persName><forename type="first">Thanh</forename><surname>Tran</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Kyumin</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Yiming</forename><surname>Liao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dongwon</forename><surname>Lee</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 27th ACM international conference on information and knowledge management</title>
		<meeting>the 27th ACM international conference on information and knowledge management</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="page" from="687" to="696" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Autorec: Autoencoders meet collaborative filtering</title>
		<author>
			<persName><forename type="first">Suvash</forename><surname>Sedhain</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Aditya</forename><forename type="middle">Krishna</forename><surname>Menon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Scott</forename><surname>Sanner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lexing</forename><surname>Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th international conference on World Wide Web</title>
		<meeting>the 24th international conference on World Wide Web</meeting>
		<imprint>
			<date type="published" when="2015">2015</date>
			<biblScope unit="page" from="111" to="112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Collaborative denoising auto-encoders for top-n recommender systems</title>
		<author>
			<persName><forename type="first">Yao</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Christopher</forename><surname>Dubois</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Alice</forename><forename type="middle">X</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Martin</forename><surname>Ester</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ninth ACM international conference on web search and data mining</title>
		<meeting>the ninth ACM international conference on web search and data mining</meeting>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="153" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Towards robust interpretability with self-explaining neural networks</title>
		<author>
			<persName><forename type="first">David</forename><surname>Alvarez</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Melis</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Tommi</forename><surname>Jaakkola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Advances in neural information processing systems</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Toward faithful explanatory active learning with self-explainable neural nets</title>
		<author>
			<persName><forename type="first">Stefano</forename><surname>Teso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Interactive Adaptive Learning (IAL 2019)</title>
		<title level="s">CEUR Workshop Proceedings</title>
		<meeting>the Workshop on Interactive Adaptive Learning (IAL 2019)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="4" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Lirme: locally interpretable ranking model explanation</title>
		<author>
			<persName><forename type="first">Manisha</forename><surname>Verma</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Debasis</forename><surname>Ganguly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 42nd International ACM SIGIR Conference on Research and Development in Information Retrieval</title>
		<meeting>the 42nd International ACM SIGIR Conference on Research and Development in Information Retrieval</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1281" to="1284" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Metrics for explainable ranking functions</title>
		<author>
			<persName><forename type="first">Abraham</forename><surname>Gale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">AmÃ©lie</forename><surname>Marian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2nd International Workshop on ExplainAble Recommendation and Search (EARS 2019)</title>
		<meeting>the 2nd International Workshop on ExplainAble Recommendation and Search (EARS 2019)</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Explaining monotonic ranking functions</title>
		<author>
			<persName><forename type="first">Abraham</forename><surname>Gale</surname></persName>
		</author>
		<author>
			<persName><forename type="first">AmÃ©lie</forename><surname>Marian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2020">2020</date>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="640" to="652" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Designing fair ranking schemes</title>
		<author>
			<persName><forename type="first">Abolfazl</forename><surname>Asudeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julia</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gautam</forename><surname>Stoyanovich</surname></persName>
		</author>
		<author>
			<persName><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2019 International Conference on Management of Data</title>
		<meeting>the 2019 International Conference on Management of Data</meeting>
		<imprint>
			<date type="published" when="2019">2019</date>
			<biblScope unit="page" from="1259" to="1276" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">On obtaining stable rankings</title>
		<author>
			<persName><forename type="first">Abolfazl</forename><surname>Asudeh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gerome</forename><surname>Jagadish</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Julia</forename><surname>Miklau</surname></persName>
		</author>
		<author>
			<persName><surname>Stoyanovich</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2018">2018</date>
			<biblScope unit="volume">12</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<analytic>
		<title level="a" type="main">Why not?</title>
		<author>
			<persName><forename type="first">Adriane</forename><surname>Chapman</surname></persName>
		</author>
		<author>
			<persName><surname>Jagadish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2009 ACM SIGMOD International Conference on Management of data</title>
		<meeting>the 2009 ACM SIGMOD International Conference on Management of data</meeting>
		<imprint>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="523" to="534" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<monogr>
		<author>
			<persName><forename type="first">Seokki</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Bertram</forename><surname>LudÃ¤scher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Boris</forename><surname>Glavic</surname></persName>
		</author>
		<idno type="arXiv">arXiv:2002.00084</idno>
		<title level="m">Approximate summaries for why and why-not provenance (extended version)</title>
		<imprint>
			<date type="published" when="2020">2020</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b51">
	<analytic>
		<title level="a" type="main">Interpretable and informative explanations of outcomes</title>
		<author>
			<persName><forename type="first">Kareem</forename><forename type="middle">El</forename><surname>Gebaly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Parag</forename><surname>Agrawal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukasz</forename><surname>Golab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Flip</forename><surname>Korn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Divesh</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="61" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b52">
	<analytic>
		<title level="a" type="main">Explanation tables</title>
		<author>
			<persName><forename type="first">Kareem</forename><forename type="middle">El</forename><surname>Gebaly</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Guoyao</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Lukasz</forename><surname>Golab</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Flip</forename><surname>Korn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Divesh</forename><surname>Srivastava</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Sat</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="page">14</biblScope>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b53">
	<analytic>
		<title level="a" type="main">A formal approach to finding explanations for database queries</title>
		<author>
			<persName><forename type="first">Sudeepa</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Dan</forename><surname>Suciu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 ACM SIGMOD international conference on Management of data</title>
		<meeting>the 2014 ACM SIGMOD international conference on Management of data</meeting>
		<imprint>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="1579" to="1590" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b54">
	<monogr>
		<title level="m" type="main">Scorpion: Explaining away outliers in aggregate queries</title>
		<author>
			<persName><forename type="first">Eugene</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Samuel</forename><surname>Madden</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b55">
	<analytic>
		<title level="a" type="main">Answering why-not questions on top-k queries</title>
		<author>
			<persName><forename type="first">Zhian</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Eric</forename><surname>Lo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1300" to="1315" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b56">
	<monogr>
		<title level="m" type="main">Answering why-not questions on reverse top-k queries</title>
		<author>
			<persName><forename type="first">Yunjun</forename><surname>Gao</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Qing</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Gang</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Baihua</forename><surname>Zheng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Linlin</forename><surname>Zhou</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015">2015</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b57">
	<analytic>
		<title level="a" type="main">Why not yet: Fixing a top-k ranking that is not fair to individuals</title>
		<author>
			<persName><forename type="first">Zixuan</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Panagiotis</forename><surname>Manolios</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Mirek</forename><surname>Riedewald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the VLDB Endowment</title>
		<meeting>the VLDB Endowment</meeting>
		<imprint>
			<date type="published" when="2023">2023</date>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="page" from="2377" to="2390" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b58">
	<analytic>
		<title level="a" type="main">On answering why-not questions in reverse skyline queries</title>
		<author>
			<persName><forename type="first">Md Saiful</forename><surname>Islam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Rui</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Chengfei</forename><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 29th International Conference on Data Engineering (ICDE)</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2013">2013. 2013</date>
			<biblScope unit="page" from="973" to="984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b59">
	<monogr>
		<title level="m" type="main">Interpretable Machine Learning</title>
		<author>
			<persName><forename type="first">C</forename><surname>Molnar</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2020">2020</date>
			<publisher>Lulu.com</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b60">
	<monogr>
		<title level="m" type="main">Consistent individualized feature attribution for tree ensembles</title>
		<author>
			<persName><surname>Scott M Lundberg</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Su-In</forename><surname>Gabriel G Erion</surname></persName>
		</author>
		<author>
			<persName><surname>Lee</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1802.03888</idno>
		<imprint>
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
	<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
